<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />

<style type="text/css">
	html, body { margin:0px; padding:0px }

	canvas {
		position: absolute;
		width: 100%;
		height: 100%;
		background: #101010;
	}
</style>

<canvas id="canvas"></canvas>

<script type="text/javascript">
	// JS utility functions
	function isdef(x) {
		return typeof(x) != 'undefined';
	}
	function toHex(x) {
		return (x>15)?x.toString(16):'0'+x.toString(16);
	}
	const ROM_NUM_KEY = [[1000,'M'],[900,'CM'],[500,'D'],[400,'CD'],[100,'C'],[90,'XC'],[50,'L'],[40,'XL'],[10,'X'],[9,'IX'],[5,'V'],[4,'IV'],[1,'I']];
	function romNum(x) {
		let r = '';
		ROM_NUM_KEY.forEach(i=>{
			while (x >= i[0]) {
				x-=i[0]; 
				r+=i[1];
			}
		});
		return r;
	}
</script>

<!-- Game data -->
<script type="text/javascript">
	// Events
	const EVENTS_DATA = [
		{
			name: 'startEvent',
			special: true
		},
		{
			name: 'Grey RepublicStartEvent',
			text: "You don't recall waking up, but you are nonetheless awake, and you don't recall being awake before now. You don't recall having memories either, but, if you did, they're no longer present. Amidst the carefully arranged dials, knobs, and pilot lights around you, you find a set of instruments that, together, provide you with a comprehensive representation of your ship's surroundings. The comfort of the well-worn seat and your ability to read each of the heavily faded labels on the controls seem to indicate that this ship must have been yours for a very long time.",
			next: 'TutorialEvent'
		},
		{
			name: 'Golden EmpireStartEvent',
			text: "You don't recall waking up, but you are nonetheless awake, and you don't recall being awake before now. You don't recall having memories either, but, if you did, they're no longer present. Your seat almost imperceptably adjusts to your movements as you look around in search of something that could tell you why you're here, or what you ought to do. You find none, leaving you in much the same position as every other sapient creature in the universe.",
			next: 'TutorialEvent'
		},
		{
			name: 'Cyan FederationStartEvent',
			text: "You don't recall waking up, but you are nonetheless awake, and you don't recall being awake before now. You don't recall having memories either, but, if you did, they're no longer present. You look over the plastic monitor in front of you, which displays a utilitarian two-dimensional representation of the surrounding celestial bodies. You can't help but recognize that you are alone here, and your mind fails to provide you with any knowledge of who, if anyone, might be out in the wider universe.",
			next: 'TutorialEvent'
		},
		{
			name: 'TutorialEvent',
			text: "You implicitly understand that you can strafe from side to side with the A and D keys, thrust forwards with the W key, and brake with the S key. Furthermore, you know that the E key can be used to interact with planets, or to trigger a jump when you are sufficiently far from the center of a system, and that the mouse, its left button, and its right button can be used to aim your ship and its weapons, fire its primary weapons, and fire its secondary weapons respectively. Finally, it comes naturally to you that the spacebar can be held to disable the IFF settings on your weaponry, which prevent it from targeting those that are not hostile to you."
		}
	];
	// Factions, ships, and weapons
	const FACTIONS_DATA = [
		{
			name: 'Player',
			color: '#FFFFFF',
			shipTable: [{
				name: 'STAR',
				shape: [[0,10],[2.5,2.5],[10,0],[2.5,-2.5],[0,-10],[-2.5,-2.5],[-10,0],[-2.5,2.5],[0,10]],
				weaponSlots: []
			}]
		},
		{
			name: 'Grey Republic',
			color: '#AAAAAA',
			relationships: {
				'Golden Empire': -100
			},
			conquestText: 'The previous inhabitants of this world have long since fled. A small cadre of combat engineers maintains the vital industry and defensive emplacements.', // The text shown on worlds that they have conquered.
			transportShip: { // The merchant ship used by this faction
				tier:-1,
				maxHealth: 2500,
				regen: .01,
				max_vel: .5,
				acceleration: .1,
				turn_rate: .025,
				maxTilt: .5,
				shape: [[105,0],[109.875,1.5],[109.875,5.25],[105.375,16.5],[97.125,21],[95.625,27.75],[67.125,33.75],[58.875,30.75],[52.875,25.5],[47.625,27],[71.625,67.5],[69.375,72.75],[41.625,24.75],[41.625,83.25],[37.875,79.5],[36.375,24.75],[29.625,25.5],[27.375,32.25],[10.875,81.75],[5.625,81],[21.375,35.25],[22.125,32.25],[13.875,32.25],[-0.375,27],[-12.375,27.75],[-20.625,33],[-27.375,35.25],[-22.125,84.75],[-27.375,87.75],[-34.125,36],[-40.875,36],[-43.125,33.75],[-46.125,26.25],[-55.125,33],[-76.125,33.75],[-85.125,50.25],[-88.125,47.25],[-79.875,30.75],[-82.125,24.75],[-93.375,30.75],[-101.625,29.25],[-102.375,26.25],[-100.875,22.5],[-100.875,15],[-101.625,12.75],[-102.375,8.25],[-99.375,3.75],[-99.375,0.75],[-99.375,-0.75],[-99.375,-3.75],[-102.375,-8.25],[-101.625,-12.75],[-100.875,-15],[-100.875,-22.5],[-102.375,-26.25],[-101.625,-29.25],[-93.375,-30.75],[-82.125,-24.75],[-79.875,-30.75],[-88.125,-47.25],[-85.125,-50.25],[-76.125,-33.75],[-55.125,-33],[-46.125,-26.25],[-43.125,-33.75],[-40.875,-36],[-34.125,-36],[-27.375,-87.75],[-22.125,-84.75],[-27.375,-35.25],[-20.625,-33],[-12.375,-27.75],[-0.375,-27],[13.875,-32.25],[22.125,-32.25],[21.375,-35.25],[5.625,-81],[10.875,-81.75],[27.375,-32.25],[29.625,-25.5],[36.375,-24.75],[37.875,-79.5],[41.625,-83.25],[41.625,-24.75],[69.375,-72.75],[71.625,-67.5],[47.625,-27],[52.875,-25.5],[58.875,-30.75],[67.125,-33.75],[95.625,-27.75],[97.125,-21],[105.375,-16.5],[109.875,-5.25],[109.875,-1.5],[105,0],[105,0]],
				engines: [
					[-100.875,-18.75],
					[-100.875,18.75]
				],
				weaponSlots: [
					{
						location: [-27.375,-87.75],
						angle: 0,
						arc: 2*Math.PI,
						secondary: false
					},
					{
						location: [-27.375,87.75],
						angle: 0,
						arc: 2*Math.PI,
						secondary: false
					}
				],

			},
			shipTable: [ // 3 ships. Drone; Fighter; Bomber; Capship.
				{
					name: "Claymore",
					unmanned: true,
					maxHealth: 110,
					regen: .1,
					max_vel: 5.5,
					acceleration: .05,
					turn_rate: .05,
					maxTilt: 1.5,
					shape: [[15.1875,0],[15.035625000000001,2.12625],[18.073125,2.73375],[15.1875,6.075],[9.1125,6.075],[-1.215,19.44],[-11.694375,13.668750000000001],[-15.643125000000001,4.2525],[-8.960625,2.12625],[-9.1125,0],[-9.1125,0],[-8.960625,-2.12625],[-15.643125000000001,-4.2525],[-11.694375,-13.668750000000001],[-1.215,-19.44],[9.1125,-6.075],[15.1875,-6.075],[18.073125,-2.73375],[15.035625000000001,-2.12625],[15.1875,0],[15.1875,0]],
					engines: [[-8.9,0]],
					weaponSlots: [{
						location: [15,0],
						angle: 0,
						arc: 1.0,
						secondary: false
					}]
				},
				{
					name: "Leviathan",
					desc: "The design of the X-5 Leviathan gunship has seen countless revisions and adaptations over its decades of service. While several attempts have been made to replace it, the costs of reorganizing the Republic's military around a new main attack craft have thus far outweighed the potential benefits, especially given the Leviathan's inarguable effectiveness against even the most novel threats.",
					maxHealth: 230,
					regen: .2,
					max_vel: 4,
					acceleration: .12,
					turn_rate: .05,
					maxTilt: 1.2,
					strafe: .5,
					strafeFuel: 40,
					strafeReload: 25,
					shape: [[10,-5],[11.0625,-6.25],[11.1875,-9],[10.3125,-11],[8.8125,-13.5],[7.6875,-13.625],[7.6875,-18.5],[8.9375,-25],[8.9375,-32.5],[8.0625,-36.125],[7.8125,-38.875],[6.9375,-40.25],[4.8125,-39.875],[2.8125,-37.375],[0.8125,-36.625],[-0.4375,-34.5],[-1.5625,-21.375],[-3.6875,-7],[-3.1875,-5],[-2.0625,-3.625],[-0.0625,-3.75],[-0.4375,-2.5],[-0.4375,-0.625],[0.0625,-0.625],[0,0],[0,0],[0.0625,0.625],[-0.4375,0.625],[-0.4375,2.5],[-0.0625,3.75],[-2.0625,3.625],[-3.1875,5],[-3.6875,7],[-1.5625,21.375],[-0.4375,34.5],[0.8125,36.625],[2.8125,37.375],[4.8125,39.875],[6.9375,40.25],[7.8125,38.875],[8.0625,36.125],[8.9375,32.5],[8.9375,25],[7.6875,18.5],[7.6875,13.625],[8.8125,13.5],[10.3125,11],[11.1875,9],[11.0625,6.25],[10,5],[10,-5],[10,-5]],
					engines: [
						[.5,0]
					],
					weaponSlots: [
						{
							location: [11.1875,-9],
							angle: 0,
							arc: 1.5,
							secondary: false
						},
						{
							location: [11.1875,9],
							angle: 0,
							arc: 1.5,
							secondary: false
						}
					]
				},
				{
					name: "Tyrant",
					desc: "The X-23 Tyrant Weapons Platform is emblematic of the Republic's military doctrine. Equipped with a pair of heavy weapons alongside a forward gun mount, it is armed well enough to open a battle by inflicting severely disproportionate casualties on the enemy, and well-protected enough to ensure that the ensuing cleanup operation will go smoothly.",
					maxHealth: 250,
					regen: .3,
					max_vel: 3.9,
					acceleration: .05,
					turn_rate: .05,
					maxTilt: 1.0,
					strafe: .5,
					strafeFuel: 15,
					strafeReload: 25,
					shape: [[19.375,0],[10,7.5],[10,13.125],[4.375,11.25],[-8.75,18.75],[-10.625,18.75],[-10.625,5.625],[-6.875,1.875],[-6.875,0],[-6.875,0],[-6.875,-1.875],[-10.625,-5.625],[-10.625,-18.75],[-8.75,-18.75],[4.375,-11.25],[10,-13.125],[10,-7.5],[19.375,0],[19.375,0]],
					engines: [
						[-7.5,0]
					],
					weaponSlots: [
						{
							location: [10,-13.125],
							angle: -.55,
							arc: 1.4,
							secondary: true
						},
						{
							location: [19.375,0],
							angle: 0,
							arc: .4,
							secondary: false
						},
						{
							location: [10,13.125],
							angle: .55,
							arc: 1.4,
							secondary: true
						}
					]
				}
			],
			weaponTable: {
				primary: [
					{
						name: "Missile Launcher",
						desc: "The ME-3 missile launcher is resource-efficient to assemble and deploy in large numbers. For that reason, automated drones and low-priority task forces make heavy use of it.",
						cost: 0,
						projectileCount: 1,
						accuracy: .1,
						rof: 120,
						projectile: { 
							damage: 70,
							damageVar: 5,
							AoE: 25, 
							lockingAngle: 1/3*Math.PI, // Weapon will lock onto the enemy with the lowest angular dist.
							trackingRate: .02, // Weapon will track the locked target at this rate.
							range: 700,
							speed: 8
						}
					},
					{
						name: "Chaingun",
						desc: "The Republic's GX-38 chaingun uses a combination of magnetic and chemical propulsion systems to fire large numbers of small, armor-penetrating projectiles at speeds sufficient to pose a threat to virtually anything.",
						cost: 0, // Cost to equip this weapon
						projectileCount: 1,
						accuracy: .1, // Max potential deviation from the firing angle
						rof: 5, // Frames between shots
						recoil: .2,
						// Ammunition and reloading
						clipSize: 40, // defaults to 1
						reloadRate: 200, // defaults to rof
						incReload: false, // defaults to false
						firingResets: true, // defaults to true
						projectile: { // Unused traits are left undefined
							damage: 22,
							damageVar: 2, // Max potential deviation from base damage
							range: 700,
							speed: 10
						}
					},
					{
						name: "Chainshotgun",
						desc: "The GX-7 sacrifices mechanical simplicity for improved screening capability. By loading and firing multiple shells at once along similar but non-identical trajectories, the 'Chainshotgun' is able to quickly deny enemy gunships the ability to close in.",
						cost: 10, // Cost to equip this weapon
						projectileCount: 3,
						accuracy: .3, // Max potential deviation from the firing angle
						rof: 8, // Frames between shots
						recoil: .5,
						// Ammunition and reloading
						clipSize: 50, // defaults to 1
						reloadRate: 20, // defaults to rof
						incReload: true, // defaults to false
						firingResets: true, // defaults to true
						projectile: { // Unused traits are left undefined
							damage: 27,
							damageVar: 1, // Max potential deviation from base damage
							range: 700,
							speed: 10
						}
					}
				],
				secondary: [
					{
						name: "Missile Pod",
						desc: "The ME-19 rapid-fire guided missile pod was designed as a means of quickly destroying entire squadrons of opposing fighters at the outset of a battle. While it does not quite live up to this lofty goal, and vessels fielding this weapon often require point defenses or significant fighter escort, it remains one of the most frightening weapons the Republic's enemies have yet encountered.",
						cost: 0,
						projectileCount: 1,
						accuracy: 1/6*Math.PI,
						rof: 20, 
						clipSize: 5,
						reloadRate: 200,
						incReload: false,
						firingResets: false,
						projectile: { 
							damage: 25,
							damageVar: 5,
							AoE: 50, // AOE applies damage to all enemies in the blast radius.
							lockingAngle: 2/3*Math.PI, // Weapon will lock onto the enemy with the lowest angular dist.
							trackingRate: .05, // Weapon will track the locked target at this rate.
							range: 900,
							speed: 7
						}
					},
					{
						name: "ECSG",
						desc: "Republic military doctrine is built around two core goals: the ability to deter a rational threat, and the ability to eradicate an irrational threat. The GXE-2 Explosive Chainshotgun delivers.",
						cost: 20,
						projectileCount: 2,
						accuracy: .1,
						rof: 7, 
						recoil: .3,
						clipSize: 10,
						reloadRate: 150,
						incReload: false,
						firingResets: true,
						projectile: { 
							damage: 30,
							damageVar: 5,
							AoE: 20, // AOE applies damage to all enemies in the blast radius.
							range: 900,
							speed: 12
						}
					}
				]
			},
			subfactions: [	// Contains any factions derived from this one, including criminals, corporations, and 'deep states'
				// These factions, on growthRate-decayRate*colonies probability, pick a random system that they've colonized.
				// If none are present, they pick a random system of their parent faction.
				// They then pick a random planet in that system, if there are any that suit them.
				// (hotDesc, temperateDesc, coldDesc) are defined if this faction can survive in these environments.
				// They add a defense fleet bought with X cash to that system
				{
					name: 'Red Commune', // Dirty commies. Kill 'em all!
					color: '#DD0000',
					relationships: {
						'Player': -100,
						'Grey Republic': -100,
						'Golden Empire': -100
					},
					//
					growthRate: .5,
					decayRate: .1,
					baseIndustry: 1,
					baseProductivity: .1,
					// +' An armed vessel unimpeded by defending vessels could level the facility.'
					hotDesc: 'You notice sun-bleached communist symbolgy written on a concealed bunker entrance.',
					temperateDesc: 'A small shipbuilding facility covered in dull red markings can be found at the base of a nearby mountain range.'
				}
			]
		},
		{
			name: 'Golden Empire',
			color: '#FFCC22',
			relationships: {
				'Grey Republic': -100
			},
			conquestText: 'The streets of this world are virtually empty, swept over by an occasional patrol. The residents that remain here spend their time indoors whenever possible, and recorded speeches in a foreign, almost alien tongue echo through the walls of every building.',
			transportShip: {
				tier: -1,
				maxHealth: 1500,
				regen: .03,
				max_vel: 1.2,
				acceleration: .05,
				turn_rate:.005,
				maxTilt: .5,
				shape: [[97.5,0],[79.125,9.75],[57.375,12.75],[37.875,12.75],[30.375,22.5],[25.125,18.75],[18.375,19.5],[13.125,23.25],[7.875,23.25],[4.875,18],[-3.375,17.25],[-13.125,21.75],[-20.625,27.75],[-10.875,31.5],[5.625,33],[28.125,35.25],[43.875,42.75],[73.875,39.75],[85.125,35.25],[81.375,45],[71.625,51],[61.125,53.25],[47.625,52.5],[28.125,52.5],[19.125,51],[10.125,50.25],[-4.875,51.75],[-18.375,58.5],[-29.625,59.25],[-15.375,47.25],[-26.625,41.25],[-46.125,37.5],[-54.375,30.75],[-46.125,28.5],[-49.125,23.25],[-61.125,18],[-70.875,5.25],[-68.625,2.25],[-68.625,0],[-68.625,0],[-68.625,-2.25],[-70.875,-5.25],[-61.125,-18],[-49.125,-23.25],[-46.125,-28.5],[-54.375,-30.75],[-46.125,-37.5],[-26.625,-41.25],[-15.375,-47.25],[-29.625,-59.25],[-18.375,-58.5],[-4.875,-51.75],[10.125,-50.25],[19.125,-51],[28.125,-52.5],[47.625,-52.5],[61.125,-53.25],[71.625,-51],[81.375,-45],[85.125,-35.25],[73.875,-39.75],[43.875,-42.75],[28.125,-35.25],[5.625,-33],[-10.875,-31.5],[-20.625,-27.75],[-13.125,-21.75],[-3.375,-17.25],[4.875,-18],[7.875,-23.25],[13.125,-23.25],[18.375,-19.5],[25.125,-18.75],[30.375,-22.5],[37.875,-12.75],[57.375,-12.75],[79.125,-9.75],[97.5,0],[97.5,0]],
				engines: [
					[-54.375,-30.75],
					[-54.375,30.75]
				],
				weaponSlots: [
					{
							location: [97.5,0],
							angle: 0,
							arc: Math.PI * 4/7,
							secondary: true
						}
				]
			},
			shipTable: [ // 3 ships. Fighter; Bomber; Capship.
				{
					name: "Ossuary",
					unmanned: true,
					maxHealth: 120,
					regen: .3,
					max_vel: 6.7,
					acceleration: .3,
					turn_rate: .08,
					maxTilt: 1.5,
					shape: [[18.75,0],[16.21875,0.9375],[3.09375,3],[6.46875,7.5],[6.46875,14.25],[-8.34375,6.75],[-8.15625,3.9375],[-3.75,3.75],[-3.75,0],[-3.75,0],[-3.75,-3.75],[-8.15625,-3.9375],[-8.34375,-6.75],[6.46875,-14.25],[6.46875,-7.5],[3.09375,-3],[16.21875,-0.9375],[18.75,0],[18.75,0]],
					engines: [[-3.75,0]],
					weaponSlots: [{
						location: [18.75,0],
						angle: 0,
						arc: 2*Math.PI,
						secondary: false
					}]
				},
				{
					name: "Vedette",
					desc: "The Vedette was the workhorse of the Imperial people, before the scarlet revolution. Nowadays, the vast stocks of these vessels are slowly running dry.",
					maxHealth: 120,
					regen: .1,
					max_vel: 5,
					acceleration: .2,
					turn_rate: .07,
					maxTilt: 1.2,
					strafe: .5,
					strafeFuel: 40,
					strafeReload: 20,
					shape: [[14.375,0],[9.375,6.25],[3.125,3.75],[2.59375,6.1875],[1.34375,4],[0.625,3.75],[-0.28125,16.625],[-1.65625,16.875],[-3.125,8.75],[-4,10],[-6,10],[-6.78125,6.6875],[-6.875,2.5],[-5.96875,1.375],[-6,0],[-6,0],[-5.96875,-1.375],[-6.875,-2.5],[-6.78125,-6.6875],[-6,-10],[-4,-10],[-3.125,-8.75],[-1.65625,-16.875],[-0.28125,-16.625],[0.625,-3.75],[1.34375,-4],[2.59375,-6.1875],[3.125,-3.75],[9.375,-6.25],[14.375,0],[14.375,0]],
					engines: [
						[-6.5,0]
					],
					weaponSlots: [
						{
							location: [14.375,0],
							angle: 0,
							arc: 1,
							secondary: false
						}
					]
				},
				{
					name: "Avant-Courier",
					desc: "Until recently, the formidable, agile Avant-Courier made up the core of the Imperial Remnant fleets. While a few core facilities are still believed to have the means to produce them, the conflict with the Federation had already stretched them thin by the time some of the last complete Avant-Courier squadrons were deployed in a futile attempt to stem the bleeding brought on by one warlord's ill-considered invasion of the Republic.",
					maxHealth: 500,
					regen: .25,
					max_vel: 2.5,
					acceleration: .1,
					turn_rate: .05,
					maxTilt: .9,
					strafe: .2,
					strafeFuel: 100,
					strafeReload: 40,
					shape: [[30.9375,0],[27.3515625,1.8984375],[9.7734375,4.1484375],[12.3046875,8.9296875],[8.4375,8.4375],[0,8.4375],[-4.4296875,10.8984375],[-2.8125,14.0625],[5.8359375,15.6796875],[14.2734375,14.8359375],[25.2421875,15.6796875],[16.6640625,19.6171875],[6.3984375,19.1953125],[1.0546875,21.4453125],[-6.3984375,19.7578125],[-12.1640625,20.6015625],[-16.875,16.875],[-19.6875,8.4375],[-22.5,5.625],[-21.1640625,3.0234375],[-20.0390625,1.7578125],[-19.6875,0],[-19.6875,0],[-20.0390625,-1.7578125],[-21.1640625,-3.0234375],[-22.5,-5.625],[-19.6875,-8.4375],[-16.875,-16.875],[-12.1640625,-20.6015625],[-6.3984375,-19.7578125],[1.0546875,-21.4453125],[6.3984375,-19.1953125],[16.6640625,-19.6171875],[25.2421875,-15.6796875],[14.2734375,-14.8359375],[5.8359375,-15.6796875],[-2.8125,-14.0625],[-4.4296875,-10.8984375],[0,-8.4375],[8.4375,-8.4375],[12.3046875,-8.9296875],[9.7734375,-4.1484375],[27.3515625,-1.8984375],[30.9375,0],[30.9375,0]],
					engines: [
						[-20.5,0]
					],
					weaponSlots: [
						{
							location: [25.2421875, -15.6796875],
							angle: 0,
							arc: .55,
							secondary: false
						},
						{
							location: [25.2421875, 15.6796875],
							angle: 0,
							arc: .55,
							secondary: true
						}
					]
				},
				{
					name: "Antiquarian",
					desc: "Each of these enormous ships is, in a figurative sense, irreplacable. One of the last enduring symbols of the hope and prosperity that the empire once held, Antiquarians are only deployed in defense of worlds that bear even greater significance.",
					maxHealth: 2500,
					regen: .4,
					max_vel: 2.5,
					acceleration: .1,
					turn_rate: .01,
					maxTilt: .5,
					strafe: .6,
					strafeFuel: 150,
					strafeReload: 200,
					shape: [[-135,0],[-129.375,7.5],[-120.375,20.25],[-120,30],[-95.625,35.25],[-82.875,45],[-76.125,46.5],[-59.625,31.5],[-44.625,26.25],[-34.125,32.25],[-37.875,45],[-49.125,49.5],[-23.625,91.5],[26.625,73.5],[27.375,79.5],[-8.625,91.5],[-0.375,105],[23.625,98.25],[25.875,105],[5.625,113.25],[9.375,122.25],[33.375,120],[50.625,93],[46.875,72],[63.375,40.5],[62.625,28.5],[75.375,25.5],[85.125,36],[90.375,34.5],[126.375,96],[131.625,89.25],[106.125,34.5],[126.375,43.5],[127.875,37.5],[164.625,63],[163.125,52.5],[135.375,30.75],[148.875,27.75],[154.875,18.75],[175.125,6],[180,0],[180,0],[175.125,-6],[154.875,-18.75],[148.875,-27.75],[135.375,-30.75],[163.125,-52.5],[164.625,-63],[127.875,-37.5],[126.375,-43.5],[106.125,-34.5],[131.625,-89.25],[126.375,-96],[90.375,-34.5],[85.125,-36],[75.375,-25.5],[62.625,-28.5],[63.375,-40.5],[46.875,-72],[50.625,-93],[33.375,-120],[9.375,-122.25],[5.625,-113.25],[25.875,-105],[23.625,-98.25],[-0.375,-105],[-8.625,-91.5],[27.375,-79.5],[26.625,-73.5],[-23.625,-91.5],[-49.125,-49.5],[-37.875,-45],[-34.125,-32.25],[-44.625,-26.25],[-59.625,-31.5],[-76.125,-46.5],[-82.875,-45],[-95.625,-35.25],[-120,-30],[-120.375,-20.25],[-129.375,-7.5],[-135,0],[-135,0]],
					engines: [
						[-120.1875,25.125],
						[-120.1875,-25.125]
					],
					strafeEngines: [
						[
							[-79.5, 45.75]
						],
						[
							[-79.5, -45.75]
						]
					],
					weaponSlots: [
						{ // Side mounts
							location: [33.375, 120],
							angle: 0,
							arc: Math.PI*2,
							secondary: false
						},
						{
							location: [33.375, -120],
							angle: 0,
							arc: Math.PI*2,
							secondary: false
						},

						{ // Front, second row
							location: [129, 92.625],
							angle: .5,
							arc: Math.PI*3/7,
							secondary: true
						},
						{
							location: [129, -92.625],
							angle: -.5,
							arc: Math.PI*3/7,
							secondary: true
						},

						{ // Front, first row
							location: [163.875, 57.75],
							angle: -0.25,
							arc: Math.PI*3/7,
							secondary: true
						},
						{
							location: [163.875, -57.75],
							angle: 0.25,
							arc: Math.PI*3/7,
							secondary: true
						}
					]
				}
			],
			weaponTable: {
				primary: [
					{
						name: "Pulse Battery",
						desc: "The Ossuaries of the Imperial Remnant, piloted by the demented husks of former citizens, make use of short-range pulse batteries as their primary weapon. Particularly talented Vedette pilots, or those serving particularly ruthless officers, have been known to field them as well.",
						cost: 0,
						projectileCount: 1,
						accuracy: 2*Math.PI,
						rof: 50,
						projectile: { 
							damage: 50,
							damageVar: 10,
							AoE: 100, 
							range: 120, // Range includes detonation if detonateOnTimeout is set.
							speed: 10,
							detonateOnTimeout: true
						}
					},
					{
						name: "Fragmentation Gun",
						desc: "The fragmentation gun is the mainstay of the Imperial Remnant's arsenal. An intricate mechanism allows its shell to fragment upon hitting a target, posing an especially severe threat to tightly grouped squadrons.",
						cost: 0,
						projectileCount: 1,
						accuracy: .07,
						rof: 12, 
						projectile: { 
							damage: 20,
							damageVar: 2,
							range: 700,
							speed: 6,
							AoE: 10,
							detonateOnTimeout: true,
							fragments: {
								count: 4,
								spread: .6,
								projectile: {
									damage: 7,
									damageVar: 2,
									range: 600,
									speed: 6
								}
							}
						}
					},
					{
						name: "Fast Seekers",
						desc: "The fast seeker launcher fires a series of rapid projectiles with slight homing capability. While the circumstances behind its development have been lost to time, it had once been a mainstay among novice pilots.",
						cost: 7,
						projectileCount: 1,
						accuracy: .01,
						rof: 8, 
						projectile: { 
							damage: 7,
							damageVar: 2,
							range: 700,
							speed: 12,
							lockingAngle: .3,
							trackingRate: .05
						}
					}
				],
				secondary: [
					{
						name: "Railgun",
						desc: "The venerable railgun, like all Imperial Remnant weapons, relies on technology whose core mode of operations is beyond contemporary man. Despite this, its core design, drawn up in far better times, is simple and reliable enough that it is one of the only Imperial weapons that is still being produced in significant quantities.",
						cost: 0,
						projectileCount: 1,
						accuracy: 0,
						rof: 30, 
						recoil: 1,
						projectile: { 
							damage: 20,
							damageVar: 5,
							range: 900,
							speed: 15,
							pierce: .5
						}
					},
					{
						name: "Linked-Fusion Gun",
						desc: "The terrifying potential of the Linked-Fusion Gun lies in its relative simplicity. An as-of-yet impenetrable interplay between cold and hot fusion mechanisms allows for raw explosive potential that dwarfs even that of the atomic missiles used by the Republic for planetary defense.",
						cost: 100,
						projectileCount: 1,
						accuracy: .3,
						rof: 400, 
						recoil: 10,
						projectile: { 
							damage: 150,
							damageVar: 50,
							range: 900,
							speed: 6,
							AoE: 100,
							detonateOnTimeout: true
						}
					}
				]
			},
			subfactions: [
				{
					name: 'Bronze Warlords',
					color: '#AA7722',
					relationships: {
						'Player': 0,
						'Golden Empire': -100,
						'Grey Republic': -100
					},
					//
					growthRate: .3,
					decayRate: .05,
					baseIndustry: 2,
					baseProductivity: 1,
					temperateDesc: 'Amidst the peaks and valleys of this barren world, you are able to locate a rogue warlord base.',
					coldDesc: 'Buried beneath several meters of ice, you notice a secret enclave belonging to a rogue warlord.'

				}
			]
		}
	];
	// Systems
	const SYSTEMS_DATA = [
		// 
		{
			name: "Vagrant",
			sunColor: '#FFAABB',
			sunRadius: 225,
			location: [480, 500],
			connections: [['Renascence', 1]], // Declare connections once. [sysName, #random systems]
			jumpRadius: 1200,
			planets: [
				{
					name: "Vagrant I", radius: 100, orbit: 750,
					desc: "Vagrant I's surface is eerily still. The lack of atmosphere means that, even atop its tallest mountain ranges, there is no wind whatsoever. Occasionally, you come across damp, shallow caverns, their walls thinly coated with a faintly glowing white moss."
				}
			]
		},
		/*
					
			Golden Empire Systems
			
		*/
		// Renascence
		// The headquarters of the warlord responsible for the invasion of the Republic
		{
			name: "Renascence",
			sunColor: '#FFFFAA',
			sunRadius: 350,
			location: [710, 475],
			connections: [["Prolegomenon",0]],
			jumpRadius: 2500,
			planets: [
				{
					name: "Renascence I", radius: 30, orbit: 400,
					desc: "Renascence I was clearly once inhabited. Faded white structures peek through the surface of the world, their purpose lost to time, but their aesthetic clearly practical in nature. A number of empty settlements dot the world, though the wear of time has ensured that barely anything remains of the oldest of them."
				},
				{
					name: "Renascence II", radius: 20, orbit: 800,
					desc: "A few thousand Imperials still live on Renascence II. Among the handful of them barely lucid enough to acknowledge your presence, there is a sense of quiet desperation. The thick metal plates at the edge of the housing facilities have long since broken open - a Republic or Federation human would not be able to breathe here.",
					initialFaction: "Golden Empire",
					industrialCapacity: 0,
					fleets: [
						{
							defensive: 1,
							shipCapacities: [1, 0, 0]
						}
					]
				},
				{
					name: "Renascence III", radius: 80, orbit: 1050,
					desc: "Renascence III remains a fairly large, functional settlement. While the ability to maintain the mechanisms that allow their minds to function has faded from Imperial memory, the decline is slowest here. The bleeding from the initial stages of the war with the Republic has slowed here, with less essential personnel now being used to crew the nearby warlord's fleets.",
					initialFaction: "Golden Empire",
					industrialCapacity: 3,
					fleets: [
						{
							defensive: 1,
							shipCapacities: [2, 1, 0]
						},
						{
							// Not defining a trait (defensive, aggressive, transports) --> 0
							shipCapacities: [2,0,0]
						}
					]
				},
				{
					name: "Renascence IIII", radius: 25, orbit: 1200,
					desc: "Attempts have clearly been made to settle Renascence IIII. Every so often, you notice a clear, exigent flaw in an outpost you explore, ranging in severity from a lack of agriculture to a major structural oversight. In the case of the latter, a number of heavily eroded skeletons can be found amongst the wreckage."
				},
				{
					name: "Renascence V", radius: 90, orbit: 1700,
					desc: "The palatial cities of Renascence V stand above a layer of silver, shining clouds. As you fly in to observe more closely, you notice that all of these but the closest to the world's capital are uninhabited, the tallest buildings plated over with thin sheets of gleaming metal.",
					initialFaction: "Golden Empire",
					industrialCapacity: 3,
					fleets: [
						{
							defensive: 1,
							shipCapacities: [2, 1, 1, 0]
						},
						{
							defensive: 0,
							aggressive: 1,
							shipCapacities: [4, 0, 0]
						},
						{
							defensive: 0,
							transports: 1,
							shipCapacities: [2, 0, 0]
						},
						{
							shipCapacities: [0,1,0]
						}
					]
				}
			]
		},
		// Prolegomenon
		// A GE system that was uninhabited until the extended conflict with the GR.
		{
			name: "Prolegomenon",
			sunColor: '#330000',
			sunRadius: 250,
			location: [700, 520], // Location in the galaxy
			connections: [["Horizon's Call",2]], // Names of systems that can be jumped to from here
			jumpRadius: 2000,
			planets: [
				{
					name: "Prolegomenon I", radius: 100, orbit: 800,
					desc: "The enormous supply base established at Prolegomenon I tells the story of the war with the Republic quite well. Vast, once-full hangers meant for Vedettes and Avant-Couriers gradually bleed their remaining ships, surrounded by graying celebretory banners. The men crewing the facility are more lucid than most of the Empire's remaining population. Unlike their husked compatriots, the death in their eyes is all too human.",
					initialFaction: "Golden Empire",
					industrialCapacity: 2, // Used to build ships. The ship built next is decided by min((count+1)/max). Costs: 1=fighter, 3=bomber, 10=capital
					fleets: [
						{
							defensive: 1,
							shipCapacities: [1, 2, 0]
						}
					]
				},
				{
					name: "Prolegomenon II", radius: 40, orbit: 1340,
					desc: "Though the surface of Prolegomenon II is green, the planet is utterly lifeless. Storms of copper dust obfuscate the sky and sweep aimlessly across the vast, empty plains.", moons: [
						{
							name: "Prolegomenon IIa", radius: 10, orbit: 100,
							desc: "The rocky, crater-filled moon of Prolegomenon II features very little that would be of interest. Even if the Empire had not fallen long before this system was discovered, it is unlikely that much attention would have been paid to Prolegomenon IIa."
						}
					]
				},
				{
					name: "Prolegomenon III", radius: 15, orbit: 1800,
					desc: "Prolegomenon III sits at the edge of the system, completely lifeless. Sheltering your ship behind the skeleton of a Pine-Class Cruiser, you can see the occasional flake of frozen carbon dioxide falling from the sky. The mountainous landscape and dim lighting reduce your field of view, but a sensor sweep indicates that a handful of shipwrecks dot the planet, likely due to its use as a navigation point by Republic strike groups."
				}
			]
		},

		/*

			Grey Republic Systems

		*/
		// Horizon's Call
		// Agricultural colony, 
		{
			name: "Horizon's Call",
			sunColor: '#8810AA',
			sunRadius: 300,
			location: [540, 770],
			connections: [['Resolution',1]],
			jumpRadius: 2400,
			planets: [
				{
					name: "Horizon's Call I", radius: 30, orbit: 700,
					desc: "In response to the violent first contact with the Imperial Remnant, the Republic quickly moved to militarize Horizon's call. While it is unlikely that the Empire would have any interest in Horizon's Call I, Republic generals, not knowing what to expect from the first foreign enemy they had faced, ordered that it be fortified.",
					initialFaction: "Grey Republic",
					industrialCapacity: 1,
					fleets: [
						{
							defensive: 1,
							shipCapacities: [1, 0, 0]
						}
					]
				},
				{name: "Horizon's Call II", radius: 70, orbit: 1160,
					desc: "Horizon's Call II was once an agricultural colony. With almost a third of the settlers it once housed taken away by the war, everywhere you go feels distinctly empty. Still, the coarse, graying settlers you occasionally spot going about their work seem undaunted, ready to see their home through its trials, or else perish alongside it.",
					initialFaction: "Grey Republic",
					industrialCapacity: 1,
					fleets: [
						{
							defensive: 1,
							shipCapacities: [2, 1, 0]
						}
					]
				},
				{name: "Horizon's Call III", radius: 60, orbit: 1600,
					desc: "A skeleton crew in a deeply buried bunker maintains the early warning systems and outer defences of the Horizon's Call system. A disproportionately large factory complex, heavily automated, houses a number of incomplete frames that will soon become Leviathan gunships.",
					initialFaction: "Grey Republic",
					industrialCapacity: 1,
					fleets: [
						{
							defensive: 1,
							shipCapacities: [1, 1, 0]
						}
					]
				}
			]
		},
		// Resolution
		// One of two core military systems
		{
			name: "Resolution",
			sunColor: '#CC5522',
			sunRadius: 500,
			location: [490, 820],
			connections: [["Daylight",0]],
			jumpRadius: 4000,
			planets: [
				{
					name: "Resolution I", radius: 85, orbit: 950,
					desc: "Resolution was one of the first systems colonized by the Republic. Since its establishment, the tremendous fortress network on Resolution I has served as a vital supply point for the nearby colonies, and a bulwark against the unknown. It is Resolution I that acts as the Republic's command center in the war against the Imperial Remnant.",
					initialFaction: "Grey Republic",
					industrialCapacity: 3,
					fleets: [
						{
							defensive: 1,
							shipCapacities: [2, 2, 2, 0]
						},
						{	// Aggressive fleets will build to capacity, then move to invade the nearest hostile system
							defensive: 0,
							aggressive: 1,
							shipCapacities: [3, 1, 1]
						},
						{
							shipCapacities: [1,1,0]
						},
						{
							transports: 1,
							shipCapacities: [2,0,0]
						}
					], 
					moons: [
						{
							name: "Resolution Ia", radius: 14, orbit: 150,
							desc: "The grim, spartan outpost on Resolution Ia is a testament to the Republic's values. Soldiers in deep gray uniforms man a densely packed array of consoles, carrying out tasks in a variety of military and scientific domains.",
							initialFaction: "Grey Republic",
							industrialCapacity: 1,
							fleets: [
								{
									defensive: 1,
									shipCapacities: [1, 0, 0]
								}
							]
						}
					]
				},
				{name: "Resolution II", radius: 40, orbit: 1600,
					desc: "The Resolution II research facility is a sight to behold. Enormous, heavily reinforced stone buildings dot the landscape, decorated with tall columns and striking statues. Within them, some of the Republic's best engineers use the technology gleamed from the nearby conflict to develop the next generation of weapons to be mounted on their Leviathan and Tyrant-class attack ships. It's said that, every so often, careful observers can spot sleek, uncanny aircraft passing them by as they land.",
					initialFaction: "Grey Republic",
					industrialCapacity: 1,
					fleets: [
						{
							defensive: 1,
							shipCapacities: [1, 1, 0]
						},
						{
							shipCapacities: [1,1]
						}
					]
				},
				{name: "Resolution III", radius: 20, orbit: 3800,
					desc: "The underground facility tasked with maintaining early warning capability in the Resolution system is manned by a skeleton crew. The men standing watch have a grim determination about them - they know that, in the event of an invasion, help would be unlikely to reach them in time.",
					initialFaction: "Grey Republic",
					industrialCapacity: 1,
					fleets: [
						{
							defensive: 1,
							shipCapacities: [1, 0, 0]
						},
						{
							shipCapacities: [0,2,0]
						}
					]
				}
			]
		},
		// Daylight
		{
			name: "Daylight",
			sunColor: '#AAAA00',
			sunRadius: 150,
			location: [550, 840],
			connections: [],
			jumpRadius: 2600,
			planets: [
				{
					name: "Daylight I", radius: 60, orbit: 950,
					desc: "Daylight I was, like Horizon's Call II, set up as an agricultural colony that would support the colonization of the outer frontier of the Republic. While the idyllic, pastoral planet and its population have been largely untouched by the war, its garrison has been substantially increased. The idea of hostile civilizations lurking just out of view, previously an academic matter, has become an ever-present concern.",
					initialFaction: "Grey Republic",
					industrialCapacity: 1,
					fleets: [
						{
							defensive: 1,
							shipCapacities: [0, 2, 0]
						},
						{
							transports: 1,
							shipCapacities: [2,0,1]
						}
					]
				},
				{
					name: "Daylight II", radius: 60, orbit: 1700,
					desc: "Daylight II was intended as a secondary colony in the system, supported by the settlement on Daylight I, and built up to support further outward exploration. The war with the Imperial Remnant routed resources and personnel away from expansion efforts, and the half-built settlements on this world now sit uninhabited."
				}
			]
		}
	];
</script>

<!-- Math -->
<script type="text/javascript">
	
	function ad(ang) {
		return ang * 180 / Math.PI;
	}
	function pt(mag, ang) {
		y = Math.sin(ang) * mag;
		x = Math.cos(ang) * mag;
		return [x,y];
	}
	function pt_add(p1, p2) {
		return [p1[0]+p2[0], p1[1]+p2[1]];
	}
	function pt_sub(p1, p2) {
		return [p1[0]-p2[0], p1[1]-p2[1]];
	}
	function pt_mul(p, m) {
		return [p[0]*m, p[1]*m];
	}
	function get_mag(p) {
		return (p[0]**2+p[1]**2)**.5;
	}
	function get_ang(p) {
		var a = Math.atan2(p[1], p[0]);
		if (a < 0) { a += 2 * Math.PI; }
		return a;
	}
	function pt_mag(p, m) {
		ang = get_ang(p);
		return pt(m, ang);
	}
	function pt_addAng(p, a) {
		mag = get_mag(p);
		ang = get_ang(p);
		ang += a;
		return pt(mag, ang);
	}
	function angDist(a1,a2) {
		let ad = Math.abs(a1-a2);
		return (ad>Math.PI)?Math.PI*2-ad:ad;
	}
	function angDir(a1, a2) {
		let ad = a1-a2;
		return (Math.abs(ad)>Math.PI?Math.sign(ad)*-1:Math.sign(ad));
	}
	function ang_turnTowards(a1, a2, amt) { // returns angle, met, direction
		if (angDist(a1,a2)<=amt) { return [a2,true, 0]; }
		let at = a2 - a1;
		let dir = 0; // Direction, if the angle is not met.
		if (at > Math.PI) {
			at -= 2 * Math.PI;
			dir = -1;
		} else if (at < -Math.PI) {
			at += 2 * Math.PI;
			dir = 1;
		}
		dir = Math.sign(at);
		var ang = a1 + dir*amt;
		if (ang < 0) {
			ang += 2 * Math.PI;
		} else if (ang > 2 * Math.PI) {
			ang -= 2 * Math.PI;
		}
		return [ang, false,dir];
	}
	function normAng(a) {
		return (a>=0)?(a%(2*Math.PI)):(a+2*Math.PI);
	}
</script>

<script type="text/javascript">
	// Classes
	/*
		obj
	*/
	class Obj {
		constructor() {
			// Initialize core variables
			this.location = [0,0];
			this.altitude = 100;
			this.tilt=0;
		}
		getRadius() {
			var r = 0;
			this.shape.forEach(function(p){
				r = Math.max(r, p[0]**2 + p[1]**2);
			});
			this.radius = r**.5;
		}

		render(ctx, c_loc) {
			var c = pt_sub(this.location, c_loc);
			var s = this.shape;
			ctx.strokeStyle = this.color;
			ctx.beginPath();
			var a = this.angle;
			var start = true;
			var t = this;
			let tiltAdj = 1;
			if (t.tilt != 0) {
				tiltAdj=Math.cos(t.tilt);
			}
			s.forEach(function(p) {
				if (t.tilt != 0) { p = [p[0], p[1]*tiltAdj] }
				p = pt_addAng(p, a);
				if (t.altitude < 100) {p = pt_mul(p, t.altitude/100); }
				p = pt_add(p, c);
				if (start) {
					ctx.moveTo(...p);
					start = false;
				} else {
					ctx.lineTo(...p);
				}
			});
			ctx.stroke();
		}
	}
	// Visual effects
	class CircleEffect {
		constructor(loc, velocity, radius, deltaRad, color,life,altitude=100) {
			/*
				Exhaust and explosions.
				Wrecks will be handled by a class that extends 'Obj'.
			*/
			this.location = loc;
			this.velocity = velocity;
			this.radius = radius;
			this.deltaRad = deltaRad;
			this.color = color;
			this.life = this.maxLife = life;
			this.altitude = altitude;
		}
		render(ctx, c_loc) {
			var c = pt_sub(this.location, c_loc);
			ctx.strokeStyle = this.color + toHex(Math.round(100*this.life/this.maxLife));
			ctx.beginPath();
			ctx.arc(c[0],c[1],this.radius*(this.altitude/100),0,2*Math.PI);
			ctx.stroke();
		}
		update(objs) {
			this.radius+=this.deltaRad;
			this.location = pt_add(this.location, this.velocity);
			if (--this.life < 0) {
				objs.fx.splice(objs.fx.indexOf(this),1);
			}
		}
	}
	// Visual effects involving polygons
	class WreckEffect extends Obj {
		constructor(shape, loc, ang, vel, tilt, color, life, maxTiltVel, smoke=false, explodes=false) {
			super();
			this.shape=shape;
			this.location = loc;
			this.angle = ang;
			this.velocity = vel;
			this.angVel = (.025-.05*Math.random());
			this.tilt = tilt;
			this.tiltVel = (maxTiltVel*Math.random());
			this.baseColor = color;
			this.color = this.baseColor+'90';
			this.life = this.maxLife = life;
			this.smokeTimer = this.smoke = smoke;
			this.explodes=explodes;
			this.processShape();
			this.getRadius();
		}

		processShape() {
			if (this.shape.length != 2) {return;}
			let base = [0,0];
			let s0 = this.shape[0];
			let s1 = this.shape[1];
			if (Math.sign(s0[0])==Math.sign(s1[0])) {
				base[0] = Math.sign(s0[0]) * Math.min(Math.abs(s0[0]), Math.abs(s1[0]))
			}
			if (Math.sign(s0[1])==Math.sign(s1[1])) {
				base[1] = Math.sign(s0[1]) * Math.min(Math.abs(s0[1]), Math.abs(s1[1]))
			}
			this.shape = [pt_sub(s0, base), pt_sub(s1, base)];
			this.location = pt_add(base, this.location);
			this.velocity = pt_add(this.velocity, pt_mul(base, .01));
		}

		render(ctx, c_loc) {
			super.render(ctx,c_loc);
		}
		update(objs) {
			this.life--;
			//
			this.tilt=normAng(this.tilt+this.tiltVel);
			//
			if (this.life<0) {
				objs.fx.splice(objs.fx.indexOf(this),1);
				let r = (.5+Math.random()*1)*this.radius;
				objs.fx.push(new CircleEffect(this.location, [0,0], r, r/20, this.baseColor,100));
				if (this.explodes==true) {
					let prev = this.shape[this.shape.length-1];
					let expMag = get_mag(this.velocity)/3;
					for (let i=0; i<this.shape.length;i++) {
						let cur = this.shape[i]
						objs.fx.push(new WreckEffect([prev,cur], this.location, this.angle, pt_add(pt(expMag,Math.random()*2*Math.PI),this.velocity), this.tilt, this.baseColor, Math.random()*200,this.tiltVel*2));
						prev=cur;
					}
				}
			}
			this.location = pt_add(this.location, this.velocity);
			this.angle += this.angVel;
			this.angVel=this.angVel<0?this.angVel+2*Math.PI:this.angVel%(2*Math.PI);
			if (this.smoke != false) {
				if (this.smokeTimer-- == 0) {
					objs.fx.push(new CircleEffect(this.location, pt(2,Math.random()*(Math.PI*2)), this.radius/3, this.radius/150, this.baseColor,70));
					this.smokeTimer=this.smoke;
				}
			}
		}
	}
	// Ship
	class Ship extends Obj {
		constructor(sd, faction, fleet) {
			super();
			// The physical aspects of the ship
			this.shape = sd.shape;
			this.getRadius();
			this.color = faction.color;
			this.engines = sd.engines;
			this.unmanned = (sd.unmanned==true);
			// The weapons of the ship
			var t = this;
			this.weaponSlots = sd.weaponSlots.map(function(w){return new WeaponSlot(w,t)});
			this.IFF = true; // Is the IFF engaged?
			// Defensive stats
			this.health = this.maxHealth = sd.maxHealth;
			this.regen = sd.regen;
			// Maneuverability stats
			this.acceleration = sd.acceleration;
			this.max_vel = sd.max_vel;
			this.turn_rate = sd.turn_rate;
			if (sd.strafe) {
				this.strafe = sd.strafe;
				this.strafeFuel = this.maxStrafeFuel = sd.strafeFuel;
				this.strafeCharge = this.strafeReload = sd.strafeReload;
				this.strafeEngines = sd.strafeEngines || [this.engines,this.engines];
			} else {
				this.strafe = 0;
			}
			this.deceleration_constant=.99;
			// 
			this.maxTilt = sd.maxTilt || Math.min(1, this.turn_rate*20);
			//
			this.player = false;
			this.faction = faction;
			this.tier = sd.tier;
			//
			this.angle = 0;
			this.location = [0,0];
			this.velocity = [0,0];
			this.jumpReady = false;
			this.jumpDelay = MAXJUMPDELAY;
			// RKV variables
			this.rkv_time = this.rkv_max = 300;
			this.rkv_count = 0;
			this.rkv_angle = -1;
			// AI variables
			this.fleet = fleet;
			if (fleet) {
				this.system = fleet.location; // The player's system is manually set upon entering a system.
			}
			this.target = false;
			this.orbitDistance = this.radius+50+Math.random()*100;
			this.orbitDirection = Math.sign(Math.random()-.5);
			// For faction purposes, track the last enemy to damage us.
			this.lastHit = false;
		}

		createWreckEffect(objs) {
			if (Math.random() > .5) {
				// Split the wreck at all points
				let adj=(this.tilt==0)?1:Math.cos(this.tilt);
				let prev = this.shape[this.shape.length-1];
				for (let i=0; i<this.shape.length;i++) {
					let cur = this.shape[i];
					objs.fx.push(new WreckEffect([[prev[0],prev[1]*adj],[cur[0],cur[1]*adj]], this.location, this.angle, pt_add(pt(this.max_vel/3,Math.random()*2*Math.PI),this.velocity), this.tilt, this.color, Math.random()*200, this.maxTilt/40));
					prev=cur;
				}
			} else { // Intact wreck
				let w = new WreckEffect(this.shape.slice(), this.location, this.angle, this.velocity, this.tilt, this.color, Math.random()*200, this.maxTilt/40, Math.floor(Math.random()*15+5), true);
				w.tilt=this.tilt;
				objs.fx.push(w);
			}
			objs.fx.push(new CircleEffect(this.location, [0,0], this.radius, this.radius/150, this.color,150, this.altitude));
		}
		
		update(objs) {
			if (this.health < 0) {
				objs.ships.splice(objs.ships.indexOf(this), 1);
				if (this.lastHit != false) {
					this.faction.handleCasualty(objs, this, this.lastHit.faction);
				}
				if (this.fleet != false) {
					if (this.tier!=-1) {
						this.fleet.shipCounts[this.tier] -= 1;
					} else {
						this.fleet.transports -= 1;
					}
				}
				// Add a wreck effect
				console.log('ship destroyed');
				this.createWreckEffect(objs);
			}
			this.health = Math.min(this.maxHealth, this.health + this.regen);
			if (this.strafeFuel!=this.maxStrafeFuel) {
				this.strafeCharge = Math.min(this.strafeCharge+1, this.strafeReload);
				if (this.strafeCharge==this.strafeReload) {
					this.strafeFuel=this.maxStrafeFuel;
					this.strafeCharge=0;
				}
			}
			this.weaponSlots.forEach(function(w){
				w.update();
			});
			this.runAI(objs);
			this.location = pt_add(this.location, this.velocity);
			// Handle RKVs
			this.handle_rkvs();
			// 
			this.jumpDelay = Math.max(0,this.jumpDelay-1);
		}

		render(context, c_loc) {
			super.render(context, c_loc);
			if (this.altitude == 100) {
				this.weaponSlots.forEach(function(w){
					w.render(context, c_loc);
				});
			}
			// Show health
			if (this.health < this.maxHealth) {
				var l = pt_sub(this.location, c_loc);
				context.strokeStyle = this.color + '22';
				context.beginPath();
				context.arc(l[0], l[1], this.radius+5, 0, 2*Math.PI);
				context.stroke();
				context.strokeStyle = this.color + '55';
				context.beginPath();
				context.arc(l[0], l[1], this.radius+5, Math.PI*(1-this.health/this.maxHealth)+Math.PI*3/2, Math.PI*(this.health/this.maxHealth)+Math.PI*5/2);
				context.stroke();
			}
			// Show RKVs
			if (this.rkv_angle > 0) {
				let l = pt_sub(this.location, c_loc);
				context.strokeStyle = '#FF0000';
				let temp = context.lineWidth;
				context.beginPath();
				context.lineWidth = 5;
				var rkvA = pt(screenWidth+screenHeight, this.rkv_angle);
				context.moveTo(...pt_add(l,rkvA));
				context.lineTo(...pt_sub(l,rkvA));
				context.stroke();
				context.lineWidth = temp;
			}	
		}

		respondToHit(objs, proj) {
			if (this.player == false) {
				let s = proj.source;
				this.lastHit = s;
				s.faction.adjRelationship(objs, this.faction,-1);
				if (!this.target || (this.target!=s && get_mag(pt_sub(this.location, this.target.location)) > get_mag(pt_sub(this.location, s.location)))) {
					this.target = s;
				}
			}
		}

		decelerate() {
			return ang_turnTowards(this.angle, get_ang(pt_sub([0,0], this.velocity)), this.turn_rate);
		}

		thrust(objs, direction=this.angle, power=this.acceleration, engines=this.engines) {
			this.applyForce(direction, power);
			let smokeAng = (direction+(.95+.1*Math.random())*Math.PI)%(2*Math.PI);
			if (Math.random() > .5) {
				let adj = (this.tilt==0)?1:Math.cos(this.tilt);
				let altAdj = (this.tilt==0)?1:Math.sin(this.tilt);
				engines.forEach(e=>{
					let loc = e;
					loc = [loc[0],loc[1]*adj];
					// constructor(loc, velocity, radius, deltaRad, color,life,altitude=100)
					let rad = 4;
					let life = 30;
					let eLoc = pt_add(pt_addAng(loc,this.angle),this.location);
					objs.fx.push(new CircleEffect(eLoc, pt_add(this.velocity, pt(this.max_vel,smokeAng)), rad, -rad/life, this.color,life,100-e[1]*altAdj));
				});
			}
		}

		applyForce(direction, magnitude) {
			var v = this.velocity;
			var v_add = pt(magnitude, direction);
			v = pt_add(v, v_add);
			this.velocity = pt_mag(v, Math.min(get_mag(v), this.max_vel));
		}

		handle_rkvs() {
			if (get_mag(this.location) > this.system.killRadius) { // Later, this could only occur in enemy systems.
				this.rkv_time -= 1;
				if (this.rkv_time <= 0) {
					this.rkv_angle = (get_ang(this.location)+Math.PI/2+Math.random()*Math.PI)%(2*Math.PI);
					this.applyForce(this.rkv_angle, 10);
					this.health -= 50+Math.random()*200;
					this.rkv_time = (.5+.5*Math.random())*this.rkv_max*.97**this.rkv_count; // Subsequent RKVs lock on faster.
					this.rkv_count += 1;
				} else {
					this.rkv_angle = -1;
				}
			} else {
				this.rkv_time = Math.min(this.rkv_max, this.rkv_time+1);
				this.rkv_count = 0;
				this.rkv_angle = -1;
			}
		}

		runAI(objs) {
			let AI_turn = false; // For the AI, if it reaches its desired angle, we act as if it's not turning.
			let turn = 0;
			let thrust = 0;
			let strafe = 0;
			let t = this;
			this.jumpReady = false;
			// One AI for all NPCs.
			if (this.player == false) {
				let locMag = get_mag(this.location);
				let sunDist = this.fleet.location.sunKillRadius+200+get_mag(this.velocity)/this.acceleration+Math.PI/this.turn_rate;
				if (locMag > this.fleet.location.killRadius) {
					AI_turn = ang_turnTowards(this.angle, get_ang(pt_sub([0,0],this.location)), this.turn_rate)
					thrust = 1;
				} else if (locMag < sunDist) { // If we're too close to the sun, get away from it.
					let sunAng = get_ang(pt_sub(this.location,[0,0]));
					AI_turn = ang_turnTowards(this.angle, sunAng, this.turn_rate);
					//
					thrust = (angDist(this.angle,sunAng)<Math.PI/2)?1:0;
					//thrust = 1;
				} else {
					if (this.target == false || objs.ships.indexOf(this.target) == -1) {
						// Find the nearest hostile ship
						this.target = false;
						var dist = Infinity;
						objs.ships.forEach(function(s){
							if (s.faction.getRelationship(t.faction) < 0) {
								var dist2 = get_mag(pt_sub(s.location, t.location));
								if (dist2 < dist) {
									dist = dist2;
									t.target = s;
								}
							}
						});
					}
					if (this.target != false) { // We have a target
						// AI
						// If our target is "friendly" to our faction, disengage IFF
						this.IFF = (this.target.faction.getRelationship(this.faction)<0);
						// If we're in the RKV killzone, get out of there.
						// Thrust towards the enemy, fire when possible.
						var p = pt_sub(this.target.location, this.location);
						var ang = get_ang(p);
						var mag = get_mag(p);
						// For now, just thrust towards the enemy, and fire every gun available at it.
						// If resources permit, more complex AI behavior can be attempted.
						thrust = 1;
						// Fire on the target with every available weapon
						let readyIn = Infinity;
						this.weaponSlots.forEach(function(w){
							let cf = w.canFire();
							readyIn = Math.min(w.weapon.readyIn(), readyIn);
							if (cf && w.weapon.projectile.range+t.radius+t.target.radius > mag) {
								// Get a firing solution
								var fs = w.getFiringSolution(t.target.velocity, t.target.location);
								if (fs != false) {
									w.fire(fs, objs, true);
								}
							}
						});
						if (readyIn>Math.PI/this.turn_rate) { ang = normAng(ang+Math.PI); } // If no weapons are ready, retreat.
						AI_turn = ang_turnTowards(this.angle, ang, this.turn_rate);
						// AI strafes out of target's gunsights
						if (this.strafe && this.strafeFuel>1) {
							let angTo = get_ang(pt_sub(this.location, this.target.location));
							if (angDist(this.target.angle, angTo)<.3
								&& angDist(this.angle, normAng(Math.PI+angTo))<.6) {
								strafe = angDir(this.target.angle, angTo);
							}
						}
					} else { // We have no target.
						// If we're in our home system, orbit our home planet. Otherwise, orbit the sun.
						let orbitDistance = this.orbitDistance;
						let p;
						if (this.fleet.location == this.fleet.homeSystem) {
							p = pt_sub(this.fleet.homeWorld.location, this.location);
							orbitDistance+=this.fleet.homeWorld.radius;
						} else {
							p = pt_sub([0,0], this.location);
							orbitDistance+=sunDist;
						}
						let dist = get_mag(p);
						let ang = get_ang(p);
						if (dist <= orbitDistance-100) { // If we're too close, move away
							ang = (ang+Math.PI)%(2*Math.PI);
						} else if (dist < orbitDistance+100) { // If we're in the right distance range, orbit.
							ang = normAng(ang+this.orbitDirection*Math.PI/2);
							if (ang < 0) { ang+=2*Math.PI; }
						}
						AI_turn = ang_turnTowards(this.angle, ang, this.turn_rate);
						thrust=1;
					}
				}
			} else {
				// Handle the player's controls.
				let temp = this.handlePlayerControls();
				AI_turn=temp[0];
				turn = temp[1];
				thrust=temp[2];
				strafe=temp[3];
			}
			// Turning
			let goalTilt;
			if (AI_turn) {
				this.angle=AI_turn[0];
				goalTilt=(AI_turn[1])?0:this.maxTilt*AI_turn[2];
			} else {
				goalTilt=(turn==0)?0:this.maxTilt*turn;
			}
			this.tilt = .96*this.tilt+.04*goalTilt;
			// Thrust control
			// Strafing
			if (this.strafe && strafe && this.strafeFuel>=1) {
				//this.thrust(objs, normAng(this.angle+Math.PI/2*strafe), this.strafe);
				this.thrust(objs, normAng(this.angle+Math.PI/2*strafe), this.strafe, this.strafeEngines[(strafe==1)?1:0]);
				this.strafeFuel-=1;
				this.strafeCharge=0;
			} else if (thrust == 1) { // Forward thrust
				this.thrust(objs);
			} else if (get_mag(this.velocity) > this.max_vel/2) {
				// If we aren't actively accelerating, slow down. This helps simulate space combat without the velocity cap, since an accelerating object will catch a non-accelerating object.
				this.velocity = pt_mul(this.velocity, this.deceleration_constant);
			}
			
		}

		handlePlayerControls() {
			let AI_turn=false;
			let thrust=0;
			let turn=0;
			let strafe=0;
			if (keysDown.indexOf(E_KEY) != -1 && this.jumpTarget != false) { // Jumping disables other controls
				if (get_mag(this.velocity) < 1.1*this.acceleration) {
					AI_turn = ang_turnTowards(this.angle, get_ang(pt_sub(this.jumpTarget.location, this.system.location)), this.turn_rate);
					this.jumpReady = AI_turn[1];
				} else { // Decelerate if moving too fast
					AI_turn = this.decelerate();
					thrust = AI_turn[1];
				}
			} else {
				let landing = false;
				if (keysDown.indexOf(E_KEY) != -1) {
					if (this.landingTarget != false && (this.landingTarget.initialFaction == false || this.landingTarget.faction.getRelationship(this.faction) >= 0)) {
						landing=true;
					}
					if (landing == true) {
						if (get_mag(this.velocity) < 1.1*this.acceleration) {
							this.altitude = Math.max(0, this.altitude-1);
						} else {
							AI_turn = this.decelerate();
							thrust = AI_turn[1];
						}
					} 
					
				}
				if (this.altitude != 100 && landing == false) { // Taking off after landing.
						landing = true;
						this.altitude = Math.min(100, this.altitude+1);
					}
				if (!landing) {
					if ((keysDown.indexOf(DOWN_KEY) != -1 || keysDown.indexOf(S_KEY) != -1) && (get_mag(this.velocity)>this.acceleration)) {
						AI_turn = this.decelerate();
						thrust = AI_turn[1];
					} else {
						// Keyboard turning/strafing
						if (keysDown.indexOf(LEFT_KEY) != -1 || keysDown.indexOf(A_KEY) != -1) {
							//turn = -1;
							strafe=-1;
						} else if (keysDown.indexOf(RIGHT_KEY) != -1 || keysDown.indexOf(D_KEY) != -1) {
							//turn = 1;
							strafe=1;
						} 
						// Mouse turning
						AI_turn = ang_turnTowards(this.angle, get_ang(mousePos), this.turn_rate);
						//
						if (keysDown.indexOf(UP_KEY) != -1 || keysDown.indexOf(W_KEY) != -1) {
							thrust = 1;
						}
					}
					// IFF is engaged whenever the spacebar isn't held
					this.IFF = (keysDown.indexOf(SPACE_KEY) == -1);
					// If the mouse is down, fire every weapon that can shoot at its position
					let t=this;
					if (leftMouseDown) {
						this.weaponSlots.forEach(function(w){
							if (!w.secondary) {
								w.fire(pt_add(mousePos, t.location), objs, restrictPlayerFire);
							}
						});
					}
					if (rightMouseDown) {
						this.weaponSlots.forEach(function(w){
							if (w.secondary) {
								w.fire(pt_add(mousePos, t.location), objs, restrictPlayerFire);
							}
						});
					}
					// Adjust angle (the AI does this directly with ang_turnTowards)
					this.angle += turn * this.turn_rate;
					if (this.angle < 0) {
						this.angle += 2*Math.PI;
					} else if (this.angle > 2*Math.PI) {
						this.angle -= 2*Math.PI;
					}
				}
			}
			if (strafe==0) { 
				this.strafeLockKey=0; 
			} else if (this.strafeLockKey!=0 && this.strafeLockKey==strafe) { 
				strafe = this.strafeLockRes;
			} else { 
				this.strafeLockKey=this.strafeLockRes=strafe;
				if (player.angle<Math.PI) { this.strafeLockRes*=-1; }
			}
			return [AI_turn, turn, thrust, strafe];
		}
	}
	/*
		
		WeaponSlot

	*/
	class WeaponSlot {
		constructor(wd, ship) {
			//
			this.shape = [
				[5,0],
				[-5,0]
			]
			// 
			this.ship = ship;
			//
			this.angle = wd.angle;
			this.arc = wd.arc;
			this.location = wd.location;
			this.secondary = wd.secondary;
			// 
			this.weapon = false;
		}

		installWeapon(weapon) {
			this.weapon = new Weapon(weapon, this);
		}

		getTrueLocation() {
			if (this.ship.tilt==0) {
				return pt_add(this.ship.location, pt_addAng(this.location, this.ship.angle));
			} else {
				return pt_add(this.ship.location, pt_addAng([this.location[0],this.location[1]*Math.cos(this.ship.tilt)], this.ship.angle));
			}
		}

		getTrueAngle() {
			return (this.angle + this.ship.angle) % (2*Math.PI);
		}

		render(context, c_loc) {
			context.strokeStyle = (this.weapon==false)?'#FF000055':'#FF0000AA';
			// Get the initial location
			var p = pt_sub(this.getTrueLocation(), c_loc);
			var a = this.getTrueAngle();
			context.beginPath();
			context.arc(p[0], p[1], (this.secondary)?5:2, 0, 2*Math.PI);
			context.stroke();
			context.beginPath();
			context.arc(p[0], p[1], 10, a - this.arc, a + this.arc);
			context.stroke();
		}

		update() {
			if (this.weapon != false) {
				this.weapon.update();
			}
		}

		canFire() {
			if (this.weapon == false) { return false; }
			return this.weapon.canFire();
		}

		getFiringSolution(targetVel, targetLoc) {
			if (this.weapon == false) { return false; }
			if (this.weapon.projectile.lockingAngle) { return targetLoc; } // No need to lead tracking weapons.
			var tv = pt_sub(targetVel,this.ship.velocity);
			var tp = pt_sub(targetLoc,this.getTrueLocation());
			var s = this.weapon.projectile.speed;
			//
			var a = (s**2-tv[0]**2-tv[1]**2);
			var b = -2*(tv[0]+tv[1]+tp[0]+tp[1]);
			var c = -(tp[0]**2+tp[1]**2);
			//
			var temp = (b**2-4*a*c);
			if (temp < 0) { return false; }
			temp = temp**.5;
			var impactTime_1 = (-b+temp)/(2*a);
			var impactTime_2 = (-b-temp)/(2*a);
			var it = Math.min(impactTime_1,impactTime_2);
			it = it>=0?it:Math.max(impactTime_1,impactTime_2);
			// 
			return pt_add(targetLoc, [tv[0]*it,tv[1]*it]);
		}

		fire(targetLoc, objs, onlyValid) {
			if (this.canFire()) {
				var pd = pt_sub(targetLoc, this.getTrueLocation());
				var tt = ang_turnTowards(this.getTrueAngle(), get_ang(pd), this.arc);
				if (tt[1] || !onlyValid) {
					let loc = this.getTrueLocation();
					for (var i = 0; i < this.weapon.projectileCount; i++) {
						var angle = tt[0];
						angle += this.weapon.accuracy * (.5-Math.random());
						objs.projs.push(new Proj(objs, loc.slice(), angle, this.ship, this.weapon.projectile));
						if (this.weapon.recoil) {this.ship.applyForce(normAng(angle+Math.PI),this.weapon.recoil * 20 / this.ship.radius);}
					}
					this.weapon.handleFire();
					/*for (let i=0; i<3; i++) {
						objs.fx.push(new CircleEffect(loc.slice(),pt(this.ship.max_vel + Math.random()*4, normAng(this.ship.angle + (.5-Math.random())*1)), 1, -1/51, this.ship.color, 50)); 
					}*/
					return true;
				}
			}
			return false;
		}
	}
	/*

		Weapon
	
	*/
	class Weapon {
		constructor(wd, ship) {
			//
			this.ship = ship;
			//
			this.rof = wd.rof;
			this.accuracy = wd.accuracy;
			this.projectile=wd.projectile;
			//
			this.projectileCount = isdef(wd.projectileCount)?wd.projectileCount:1;
			//
			this.recoil=wd.recoil||0;
			//
			this.clipSize = isdef(wd.clipSize)?wd.clipSize:1;
			this.reloadRate = isdef(wd.reloadRate)?wd.reloadRate:this.rof;
			this.incReload = isdef(wd.incReload)?wd.incReload:false;
			this.firingResets = isdef(wd.firingResets)?wd.firingResets:true;
			this.clipAmmo = this.clipSize; // Initialize the ammount of ammo in the clip.
			this.reloadProg = 0;
			//
			this.lastFired = 0;
		}

		update() {
			this.lastFired += 1;
			this.reloadProg = this.clipAmmo==this.clipSize?0:this.reloadProg+1;
			if (this.reloadProg >= this.reloadRate) {
				this.clipAmmo = this.incReload?Math.min(this.clipAmmo+1,this.clipSize):this.clipSize;
				this.reloadProg = 0;
			}
		}

		readyIn() {
			return (this.clipAmmo==0)?this.reloadRate-this.reloadProg:this.rof-this.lastFired;
		}

		canFire() {
			return (this.lastFired>=this.rof)&&(this.clipAmmo>0);
		}

		handleFire() {
			this.lastFired = 0;
			this.clipAmmo -= 1;
			if (this.firingResets==true) { this.reloadProg=0; }
		}
	}
	/*
		
		Projectile

	*/
	class Proj extends Obj {
		
		constructor(objs,location, angle, source, pd) {
			super();
			//
			this.shape = [
				[pd.speed,0],
				[-pd.speed,0]
			];
			this.getRadius();
			// 
			this.source = source;
			this.IFF = source.IFF;
			this.color = this.IFF ? source.color : '#FF0000';
			//
			this.angle = angle;
			this.location = pt_add(location, pt(this.radius, this.angle));
			this.velocity = pt_add(this.source.velocity, pt(pd.speed, angle));
			// 
			this.damage = pd.damage+pd.damageVar*(.5-Math.random());
			// Special
			// Pierce
			this.pierce = isdef(pd.pierce)?pd.pierce:false;
			this.pierced = [];
			// AoE
			this.AoE = isdef(pd.AoE)?pd.AoE:false;
			// Tracking
			this.target = false;
			if (isdef(pd.lockingAngle)) {
				// Only lock onto hostiles, regardless of IFF.
				var t = this;
				var closest = Math.PI*2;
				objs.ships.forEach(s=>{
					if ((t.source.faction.getRelationship(s.faction)<0) &&
						(get_mag(pt_sub(t.location,s.location))<=pd.range)) {
						let temp = angDist(t.angle, get_ang(pt_sub(s.location,t.location)));
						if (temp < closest) { closest=temp; t.target=s;}
					}
				});
				t.trackingRate = pd.trackingRate;
			}
			// Fragmentation
			this.fragments = isdef(pd.fragments)?pd.fragments:false;
			// Detonation
			this.detonateOnTimeout = (pd.detonateOnTimeout==true);
			// Range
			if (this.detonateOnTimeout) {
				let sub = (this.AoE)?this.AoE:0;
				sub = (this.fragments)?this.fragments.projectile.range+sub:sub;
				this.life = (pd.range-sub)/pd.speed;
			} else {
				this.life = pd.range/pd.speed;
			}
		}

		applyAoE(objs, hit=false) { // Apply AOE, ignoring the original target.
			var t=this;
			objs.ships.forEach(s => {
				if ((s != hit) &&
					(t.source.faction.getRelationship(s.faction)<0 || (t.source!=s && t.IFF == false)) &&
					(get_mag(pt_sub(t.location, s.location)) < s.radius+t.AoE)) {
					s.health -= t.damage;
					s.respondToHit(objs, t);
				}
			}); 
			// Add an explosion effect.
			objs.fx.push(new CircleEffect(this.location.slice(), [0,0], this.AoE, this.AoE*.01, this.color,100));
		}

		fragment(objs, hit=false) {
			let f = this.fragments;
			for (let i=0;i<f.count;i++) {
				let ang = this.angle + (.5-1*Math.random())*f.spread;
				ang = (ang>=0)?(ang<2*Math.PI?ang:ang-2*Math.PI):ang+2*Math.PI;
				let proj = new Proj(objs, this.location, ang, this.source, f.projectile);
				proj.IFF = this.IFF; // IFF comes from the projectile, not the source ship.
				proj.color = this.color;
				if (hit) {proj.pierced.push(hit);} // Ignore the ship we've already hit.
				objs.projs.push(proj);
			}
		}

		update(objs) {
			// Handle tracking
			if (this.target!=false) {
				// tracking rate
				if (objs.ships.indexOf(this.target)==-1) {
					this.target = false;
				} else {
					let newAng = ang_turnTowards(this.angle,get_ang(pt_sub(this.target.location,this.location)), this.trackingRate)[0];
					let vMag = get_mag(this.velocity);
					this.velocity = pt(vMag, newAng);
					this.angle = newAng;
					// Generate exhaust
					let smokeAng = (this.angle+(.95+.1*Math.random())*Math.PI)%(2*Math.PI);
					if (Math.random() > .5) {
						objs.fx.push(new CircleEffect(this.location.slice(), pt_add(this.velocity, pt(vMag,smokeAng)), 2, .5, this.color,30));
					}
				}
			}
			//
			this.location = pt_add(this.location, this.velocity);
			this.life -= 1;
			if (this.life <= 0) {
				objs.projs.splice(objs.projs.indexOf(this), 1);
				if (this.detonateOnTimeout) {
					// Apply AoE
					if (this.AoE!=false) {this.applyAoE(objs, s);}
					// Apply fragmentation
					if (this.fragments!=false) {this.fragment(objs,s);}
				}
			} else {
				let t = this;
				let dead = false;
				objs.ships.forEach(function(s){
					if (dead == false) {
						if ((t.source != s) && 
							(t.pierced.indexOf(s)==-1) && // Handle pierce
							(t.source.faction.getRelationship(s.faction) < 0 || t.IFF == false) && // IFF
							(get_mag(pt_sub(t.location, s.location)) < t.radius + s.radius*(s.altitude/100)) // For now, check by radius
							) {
							// The weapon's base damage
							s.health -= t.damage;
							s.respondToHit(objs, t);
							if (t.pierce!=false && t.pierce>Math.random()) {
								t.pierced.push(s);
							} else {
								objs.projs.splice(objs.projs.indexOf(t), 1);
								dead=true;
								// Apply AoE
								if (t.AoE!=false) {t.applyAoE(objs, s);}
								// Apply fragmentation
								if (t.fragments!=false) {t.fragment(objs,s);}
							}
						}
					}
				});
			}
		}

	}
	/*

		Faction

	*/
	class Faction {
		constructor(fd, objs) {
			// Preprocess the shiptable
			for (let i=0;i<fd.shipTable.length;i++){ fd.shipTable[i].tier=i; }
			// 
			this.name = fd.name;
			this.relationships = {};
			for (var f in fd.relationships) {
				this.relationships[f] = [fd.relationships[f]];
			}
			this.color = fd.color;
			// Ship table. A list of 3 ship specifications, including weapon slots,
			// shape, acceleration, max velocity, turn rate, health, and regen rate.
			this.shipTable = fd.shipTable;
			this.transportShip = fd.transportShip;
			// Weapon table. A list of primary and secondary weapons.
			this.weaponTable = fd.weaponTable;
			// Text displayed in place of the description of conquered planets.
			this.conquestText = fd.conquestText;
			// This.subfactions = 
			let subfactions = [];
			if (isdef(fd.subfactions)) {
				fd.subfactions.forEach(sf => {
					sf.shipTable = fd.shipTable;
					sf.transportShip = fd.transportShip;
					sf.weaponTable = { // Subfactions don't get the heavy weapons
						primary: fd.weaponTable.primary.slice(0,1),
						secondary: fd.weaponTable.secondary.slice(0,1)
					};
					let newSF = new SubFaction(sf,objs);
					subfactions.push(sf.name);
				});
			}
			this.subfactions = subfactions;
			//
			objs.factions[this.name]=this;
		}

		setRelationship(faction, value) {
			var relationship = [value];
			this.relationships[faction.name] = faction.relationships[this.name] = relationship;
		}

		adjRelationship(objs, faction, value) {
			let iRel = this.getRelationship(faction);
			let fRel = faction.relationships[this.name] = [iRel + value];
			// Track changes in faction politics
			if (Math.sign(iRel)!=Math.sign(fRel)) {
				let fc = objs.univChanges.factionChanges;
				let k = [faction.name,this.name].sort().join(' and ');
				fc[k] = isdef(fc[k])?[fc[k][0],Math.sign(fRel)]:[Math.sign(iRel),Math.sign(fRel)];
			}
			//
			this.relationships[faction.name] = fRel;
			
		}

		getRelationship(faction) {
			if (faction==this) { return Infinity; }
			if (!isdef(this.relationships[faction.name])) {
				if (!isdef(faction.relationships[this.name])) {
					this.relationships[faction.name] = faction.relationships[this.name] = [0];
				} else {
					this.relationships[faction.name] = faction.relationships[this.name];
				}
			}
			return this.relationships[faction.name][0];
		}

		armShip(s, tier=-1) {
			var wt = this.weaponTable;
			var pmy = wt.primary[Math.floor(Math.random()*wt.primary.length)];
			var scy = wt.secondary[Math.floor(Math.random()*wt.secondary.length)];
			if (tier!=-1) { pmy=wt.primary[tier]; scy=wt.secondary[tier]; }
			s.weaponSlots.forEach(function(w){
				w.installWeapon(w.secondary?(new Weapon(scy)):(new Weapon(pmy)));
			});
		}

		handleAssetLost(objs, killValue, killerFaction) {
			// If the killer faction was previously seen as a friend, cut relationship by half.
			if (killerFaction==this || !killerFaction) { return; } // Infighting does not affect relationships between factions, nor do environmental deaths
			let cur = this.getRelationship(killerFaction);
			if (cur > 0) {
				this.adjRelationship(objs, killerFaction, -cur/2);
			}
			this.adjRelationship(objs, killerFaction, -killValue * 10);
			let totalHate = 0;
			let enemies = [];
			let hateValues = [];
			let totalSympathy = 0;
			let allies = [];
			let sympathyValues = [];
			for (let k in this.relationships) {
				let r = this.relationships[k][0];
				if ((k != 'Player') && (k != this.name)) { // The player decides how much he likes a faction, not the game.
					if (r < 0) { 
						totalHate += -r;
						enemies.push(objs.factions[k]);
						hateValues.push(-r);
					} else if (r > 0) {
						totalSympathy += r;
						allies.push(objs.factions[k]);
						sympathyValues.push(r);
					}
				}
			}
			// Factions like it when you destroy their enemies' assets.
			// I suppose I could use softmax or something, but linear weighting works fine.
			for (var i=0; i<enemies.length;i++) {
				let repGain = Math.round(killValue * 5 * hateValues[i]/totalHate);
				killerFaction.adjRelationship(objs, enemies[i], repGain);
			}
			if (killerFaction.name=='Player' && enemies.length>0) {
				addMsg('Gained reputation with ' + enemies.map(x=>x.name).join(', ') + '.');
			}
			// Factions dislike it when you destroy their allies' assets
			for (var i=0; i<allies.length;i++) {
				let repLoss = -Math.round(killValue * 5 * sympathyValues[i]/totalSympathy);
				killerFaction.adjRelationship(objs, allies[i], repLoss);
			}
			if (killerFaction.name=='Player' && allies.length>0) {
				addMsg('Lost reputation with ' + allies.map(x=>x.name).join(', ') + '.');
			}
		}

		handleCasualty(objs, ship, killerFaction) {
			// Factions don't like it when you kill their ships.
			let killValue = (ship.tier!=-1)?shipCosts[ship.tier]:50; // Transports have a flat value of 50.
			this.handleAssetLost(objs, killValue, killerFaction);
		}

		// Check hostile system
		checkHostileSystem(sys) {
			for(var i=0;i<sys.planets.length;i++){
				let p = sys.planets[i];
				if (p.faction != false && p.faction.getRelationship(this) < 0) {
					return true;
				}
			}
			return false;
		}
	}
	/*
		SubFaction
		 - A faction that occasionally colonizes systems within a larger faction's area of influence
	*/
	class SubFaction extends Faction {
		constructor(sf, objs) {
			super(sf,objs);
			this.colonies = 0;
			this.hotDesc = sf.hotDesc;
			this.coldDesc = sf.coldDesc;
			this.temperateDesc = sf.temperateDesc
			this.growthRate = sf.growthRate;
			this.decayRate = sf.decayRate;
			this.baseIndustry = sf.baseIndustry;
			this.baseProductivity = sf.baseProductivity;
		}

		habitable(p,s) {
			return (((isdef(this.coldDesc)&&s.isCold(p)) ||
				(isdef(this.hotDesc)&&s.isHot(p)) ||
				(isdef(this.temperateDesc)&&(!s.isCold(p)&&!s.isHot(p)))) &&
				((p.orbit-p.radius)>(100+s.sunKillRadius))
				);
		}
	}
	/*

		Fleet

		- Fleets cannot be destroyed. (empty) Defense fleets can switch factions when their system is conquered, and
		invasion fleets are relocated to their home system when defeated.
	*/
	class Fleet {
		constructor(homeSystem, homeWorld, faction, fd) {
			// 
			this.homeSystem = this.location = homeSystem;
			this.homeWorld = homeWorld;
			//
			this.faction = faction;
			this.aggressive = fd.aggressive || 0;
			this.defensive = fd.defensive || 0;
			this.transportCapacity = fd.transports || 0;
			this.transports = 0;
			// Defensive fleets start out full, other fleets start out empty.
			this.shipCapacities = fd.shipCapacities.slice();
			this.shipCounts = (this.defensive?this.shipCapacities.slice():new Array(this.shipCapacities.length).fill(0));
			if (this.shipCounts.length<shipCosts.length) {
				let x = shipCosts.length-this.shipCapacities.length;
				this.shipCapacities = this.shipCapacities.concat(new Array(x).fill(0));
				this.shipCounts = this.shipCounts.concat(new Array(x).fill(0));
			} // Pad the ship count array to allow backwards compatablity.
			// Determine the fleet's name.
			this.name = homeWorld.name;
			this.name += this.defensive?' Defense':(this.aggressive?' Invasion':(this.transportCapacity?' Cargo':' Mercenary'));
			this.name += ' Fleet';
		}

		moveToSystem(system) {
			// Move to a new system. Build a list of hostile fleets. Calculate battle results. Distribute casualties.
			console.log(this.name + ' moved from ' + this.location.name + ' to ' + system.name + '.');
			this.location = system;
		}

		tradePlanet(p) {
			if ((p.faction) && (p.faction.getRelationship(this.faction)>0)) {
				p.storedIndustry = MAX_INDUSTRY;
			}
			p.moons.forEach(m=>{
				this.tradePlanet(m);
			});
		}

		trade() {
			if (this.transports>0) {
				this.location.planets.forEach(p=>{
					this.tradePlanet(p);
				});
			}
		}

		checkTradePlanet(p) {
			if ((p.faction) && (p.faction.getRelationship(this.faction)>0) && (p.storedIndustry < MAX_INDUSTRY)) { return true; }
			p.moons.forEach(m=>{
				if (this.checkTradePlanet(m)) { return true; }
			});
			return false;
		}

		// Check if a system is in need of supplies
		checkTradeSystem(sys) {
			let t = this;
			let r = false;
			if (sys==this.homeSystem) {return false;} // Can't resupply home system
			sys.planets.forEach(p=>{
				r = r || this.checkTradePlanet(p);
			});
			return r;
		}

		randomWalk(throughHostile=false) {
			let i = Math.floor(Math.random()*this.location.connections.length);
			let s = this.location.connections[i];
			if ((throughHostile==true) || (this.faction.checkHostileSystem(s)==false)) {
				this.moveToSystem(s);
			}
		}

		hasShips() {
			if (this.transports>0) { return true; }
			let out = false;
			this.shipCounts.forEach(c=> {if (c>0) { out=true; }});
			return out;
		}

		attackFleet(fleet) {
			/*
				Ships perform well against the next rank, evenly against each other, poorly against 
				everything higher.
			*/
			var tsc = this.shipCounts;
			var fsc = fleet.shipCounts;
			console.log(this.name + ' is attacking ' + fleet.name + ".");
			console.log(tsc);
			console.log(fsc);
			// Sweep down the list to determine whether a message should be sent after the battle concludes.
			let notable = fleet.hasShips() && this.hasShips();
			// Initial skirmishes. Attack your own tier, then the next tier up.
			for (var i = 0; i<tsc.length; i++) {
				let cas = Math.min(tsc[i],fsc[i]);
				tsc[i] -= cas;
				fsc[i] -= cas;
				if (i+1<tsc.length) {
					let atkr = (tsc[i] > 0)?tsc:fsc;
					let dfdr = (tsc[i] == 0)?tsc:fsc;
					let atkPow = atkr[i] * shipCosts[i] * 2;
					let defPow = dfdr[i+1] * shipCosts[i+1];
					cas = Math.min(atkPow, defPow);
					// Round up defpow after dividing.
					atkPow -= cas;
					defPow -= cas;
					atkr[i] = Math.floor(atkPow / shipCosts[i] / 2);
					dfdr[i+1] = Math.ceil(defPow / shipCosts[i+1]);
				}
			}
			// Cleanup. The most powerful ships sweep down the list until there are no survivors on one side.
			for (var i = tsc.length-1; i >= 0; i--) {
				let atkr = tsc[i]>0?tsc:fsc;
				let dfdr = tsc[i]==0?tsc:fsc;
				let atkPow = atkr[i]*shipCosts[i]*2;
				let j = i-1;
				while (atkPow != 0 && j >= 0) {
					let defPow = shipCosts[j]*dfdr[j];
					let cas = Math.min(atkPow, defPow);
					defPow -= cas;
					dfdr[j] = Math.floor(defPow/shipCosts[j]);
					atkPow -= cas;
					j -= 1;
				}
				atkr[i] = Math.ceil(atkPow / shipCosts[i] / 2);
			}
			// Sweep down the list one last time to check for survivors
			let win = false;
			for (let i = 0; i < tsc.length; i++){
				if (tsc[i]>0) {win=true;}
			}
			console.log('Results:');
			console.log(tsc);
			console.log(fsc);
			// The losing side's transports are destroyed.
			if (win) {
				fleet.transports=0;
			} else {
				this.transports=0;
			}
			if (notable) {addMsg(win?'The '+this.name+' attacked and destroyed the '+fleet.name+'.':'The '+this.name+' was destroyed in an engagement with the '+fleet.name+'.');}
			return win;
		}

		invadeSystem(objs) {
			if (!this.hasShips()) { return; }
			// Fight each hostile fleet until we are dead or no hostile fleets remain.
			var fleets = objs.globalFleets.filter(f => f.location == this.location);
			var i = 0;
			var win = true;
			while (win == true && i < fleets.length) {
				var f = fleets[i];
				if (f.faction.getRelationship(this.faction) < 0) {
					win = this.attackFleet(f);
				}
				i += 1;
			}
			if (win) {
				this.location.planets.forEach(p => {
					if (p.initialFaction != false) { // uninhabited worlds remain empty.
						// Take control of all defensive fleets in the conquered system
						fleets.forEach(f=>{
							if (f.defensive) {
								f.faction = this.faction;
							}
						});
						p.faction = this.faction;
						p.storedIndustry=0;
						addMsg(p.name + ' is now held by the ' + this.faction.name + '.');
					} else if (p.faction != false) {
						// Destroy hostile fleets
						fleets.forEach(f=>{
							if (f.defensive) {
								objs.globalFleets.splice(objs.globalFleets.indexOf(f),1);
							}
						});
						// Destroy hostile colonies
						addMsg('The ' + p.faction.name + ' presence on ' + p.name + ' has been destroyed by the ' + this.faction.name + '.');
						p.faction.colonies--;
						p.faction = false;
						p.storedIndustry=0;
						p.industrialCapacity=0;
					}
				});
				
			}
		}

		handleBattles(objs) {
			// Handles invasions before movement is processed.
			if (this.hasShips()) {
				if (this.faction.checkHostileSystem(this.location)) {
					this.invadeSystem(objs);
					this.fought=true; // Can't take any actions this turn if we've spent it fighting.
				}
			}
		}

		// Handle movement after restocking
		update(objs) {
			this.prevSystem = this.location; // Allows us to place the fleet in a suitable in-system position.
			let shipCount = this.transports;
			this.shipCounts.forEach(c => {shipCount+=c;});
			if (!this.hasShips()) {
				if (this.location!=this.homeSystem) {
					this.moveToSystem(this.homeSystem); // Destroyed fleets return to their home systems to restock.
				}
			} else if (this.faction.checkHostileSystem(this.location)) { // If we start in a hostile system, simulate a battle.
				// Invasions done in handleBattles
			} else if (this.transports>0 && this.checkTradeSystem(this.location)) {
				this.trade();
				console.log(this.name + " resupplied " + this.location.name + ".");
			} else {
				if (this.defensive) {
					// Defensive fleets don't move.
				} else { // No fleet will leave its home system below capacity
					var proceed=true;
					if (this.location == this.homeSystem) {
						for (var i=0;i<this.shipCounts.length;i++) {
							if (this.shipCounts[i]<this.shipCapacities[i]) {
								proceed = false;
							}
						}
					}
					if (proceed == true) {
						let t = this;
						if (this.aggressive) { // Nearest hostile system
							let ts = this.location.seekSystem(function(x) { return t.faction.checkHostileSystem(x); }, false);
							if (ts) {this.moveToSystem(ts)};
						} else if (this.transports > 0) { // Nearest system in need
							let ts = this.location.seekSystem(function(x) { return t.checkTradeSystem(x); }, this.faction);
							if (ts) {this.moveToSystem(ts)};
						} else if (this.transportCapacity > 0) { // Return to home system
							let ts = this.location.seekSystem(function(x) { return (x==t.homeSystem); }, this.faction);
							if (ts) {this.moveToSystem(ts)};
						} else { // Mercenary fleets randomly wander non-hostile space
							this.randomWalk();
						}
					}
				}
			}
		}

		buyShip(value) {
			// What ship do we want?
			var tgt = -1;
			var need = 1.1;
			for (var i=0; i < this.shipCounts.length; i++) {
				var cap = this.shipCapacities[i];
				var cnt = this.shipCounts[i];
				if (cap != 0 && cnt != cap) {
					var n = (cnt+1)/cap;
					if (n <= need) {
						tgt = i;
						need = n;
					}
				}
			}
			if (tgt == -1 || value < shipCosts[tgt]) {
				return [(tgt==-1?0:1), value];
			} else {
				value -= shipCosts[tgt];
				this.shipCounts[tgt] += 1;
				return [2, value];
			} // 0: At capacity, 1: Can't afford target ship, 2: Purchased a ship
		}

		restock(value) { // Attempt to restock with a certain amount of industry
			var status = 2;
			while (status == 2) {
				var res = this.buyShip(value);
				status = res[0];
				value = res[1];
			}
			// Merchant fleets restock their transports if they're at capacity at their homeworld.
			if (status==0 && this.location == this.homeSystem) {
				this.transports = this.transportCapacity;
			}
			//
			return [value, (status==1)];
		}
	}
	/*

		System

	*/
	const genSysNames = ['alpha','beta','gamma','delta','epsilon','zeta','eta','theta','iota','kappa','lambda','mu','nu','xi','omicron','pi','rho','sigma','tau','upsilon','phi','chi','psi','omega'];
	const genMoonSuffixes = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];
	class System {

		constructor(objs, sd) {
			this.name = sd.name;
			objs.systems[this.name] = this;
			//
			this.jumpRadius = sd.jumpRadius;
			this.killRadius = this.jumpRadius + 500
			// 
			this.connections = sd.connections;
			// The sun
			this.sunRadius = sd.sunRadius;
			this.sunKillRadius = sd.sunRadius*1.5;
			this.sunColor = sd.sunColor;
			// 
			this.location = sd.location; 
			this.planets = sd.planets;
			var t = this;
			this.planets.forEach(function(p) {
				t.initPlanet(p, objs);
			});
		}

		buildConnections(objs) {
			// Build random systems associated with connections.
			let t = this;
			this.connections.forEach(function(c) {
				if (Array.isArray(c))
					t.buildRandomSystems(objs, c);
			});
		}

		isHot(p, s=false) {
			if (!s) {s=this;}
			return (p.orbit < this.sunRadius*3);
		}

		isCold(p, s=false) {
			if (!s) {s=this;}
			return (p.orbit > s.sunRadius*5);
		}

		generateDesc(p, s) {
			let hot = this.isHot(p,s);
			let cold = this.isCold(p,s)
			if (hot) {
				p.desc=p.name + ' is an unremarkable world, its features long since melted away by the searing heat of the local star.';
			} else if (cold) {
				p.desc='You are on the surface of yet another cold, dim world in the endless abyss. The void of space looks even emptier from ' + p.name + '.';
			} else {
				p.desc=p.name + ' is a rocky, temperate world. The warm sun shines down on your vessel, and the unique beauty of the alien sky almost makes you forget that, due to the lack of atmosphere, nothing is ever likely to come of this world.';
			}
		}

		generateMoonDesc(m,p,s) {
			let hot = this.isHot(p,s);
			let cold = this.isCold(p,s)
			if (hot) {
				m.desc=m.name + ' shields ' + p.name + ' from some of ' + s.name + "'s intense heat, but not enough to make it remotely livable.";
			} else if (cold) {
				m.desc='From the icy surface of '+m.name+", you can see "+p.name+" floating in the distance.";
			} else {
				m.desc=m.name+" has clearly orbited " + p.name + ' for ages. Countless craters on its surface denote the many asteroid impacts it has spared its planet.';
			}
		}

		buildRandomPlanets(nsd) {
			let ps = [];
			let pr = 0.9;
			let minR = nsd.sunRadius;
			let varR = nsd.jumpRadius-nsd.sunRadius;
			while (Math.random() < pr) { // Get planet count
				pr = .7;
				let r = 10 + Math.random()*100;
				let ms = [];
				while (Math.random() < 0.3) {
					let mr = Math.max(10, r/2*Math.random());
					ms.push({
						radius: mr,
						orbit: r+mr+10+50*Math.random()
					});
				}
				ps.push({
					radius: r,
					orbit: minR+varR*Math.random(),
					moons: ms
				});
			}
			// Sort planets by distance. Purge intersecting planets.
			ps.sort(function(a,b) { return a.orbit - b.orbit});
			let c = 1;
			let prev = nsd.sunRadius;
			ps.forEach(p=>{
				p.name = nsd.name + " " + romNum(c);
				c++;
				let trueR = p.radius;
				// Handle moons
				p.moons.sort(function(a,b) { return a.orbit - b.orbit});
				let mc = 1;
				let ms = [];
				p.moons.forEach(m=>{
					if (m.orbit-m.radius<trueR+10) {
						// Moons that intersect each other are removed.
					} else {
						if (m.orbit+m.radius>trueR) {
							trueR = m.orbit+m.radius;
						}
						m.name = p.name+this.getSuffix(mc,genMoonSuffixes).slice(1);
						this.generateMoonDesc(m,p,nsd);
						ms.push(m);
						mc += 1;
					}
				});
				p.moons = ms;
				//
				
				//
				if ((p.orbit-trueR-10 > prev) && (p.orbit+trueR<nsd.jumpRadius)) {
					prev = p.orbit+trueR;
					this.generateDesc(p, nsd); // Generate description
					nsd.planets.push(p);
				}
			});
			// The jump radius should be at least 500 more than the farthest planet's orbits
			if (ps.length>0){ nsd.jumpRadius = Math.max(nsd.jumpRadius, ps[ps.length-1].orbit+500); }
		}

		getSuffix(n,names) {
			n--;
			let name = "";
			let l = names.length;
			let len=1;
			let t = n;
			while (t>=l**len) {
				t -= l**len;
				len+=1;
			}
			//
			while (len>0) {
				let ix = Math.floor(t/l**(len-1))%l;
				name = name + " " + names[ix];
				len-=1;
			}
			return name;
		}

		buildRandomSystems(objs, c) {
			let ts = objs.systems[c[0]];
			let cs = this.connections;
			let ix = cs.indexOf(c);
			let dn = c[0];
			if (c[1]!=0) {
				let rv = 1;
				let rn = this.name;
				if (isdef(this.randVar)) {
					rv=this.randVar+1;
					rn=this.randName;
				}
				let nsn = rn + this.getSuffix(rv, genSysNames);
				// Build the system
				let sr = 50 + Math.random()*500; // star radius
				let jr = sr + 700 + 5 * sr * Math.random();
				let scr = 155+Math.round(Math.random()*100); // star color
				let scg = Math.round(Math.random()*scr);
				let scb = Math.round(Math.random()*scg);
				let sc = '#'+toHex(scr)+toHex(scg)+toHex(scb);
				let loc = pt_add(pt_add(this.location, pt_mul(pt_sub(ts.location, this.location), 1/(c[1]+1))), [Math.random()*30,Math.random()]);
				// Generate the system
				let nsd = {
					name: nsn,
					sunRadius: sr,
					sunColor: sc,
					location: loc,
					jumpRadius: jr,
					connections: [[c[0],c[1]-1]],
					planets: []
				}
				//
				this.buildRandomPlanets(nsd);
				//
				let s = new System(objs, nsd);
				s.generated=true;
				s.randVar = rv;
				s.randName = rn;
				s.randTarget = c[0];
				s.buildConnections(objs); // Recursive.
				ts = s;
			}
			cs.splice(ix,1,ts.name); // Replace the connection tuple with its name.
			ts.connections.push(this.name);
		}

		initPlanet(p, objs) {
			if (!isdef(p.initialFaction)) { p.initialFaction = p.faction = false; p.storedIndustry=0; p.industrialCapacity=0;} else {
				p.faction = objs.factions[p.initialFaction];
				p.storedIndustry = 0; // Stored industry
			}
			if (!isdef(p.moons)) { p.moons = []; }
			var t = this;
			p.moons.forEach(function(m){ t.initPlanet(m, objs); });
			// At the start of the game, all planets' defensive fleets are at capacity.
			if (isdef(p.fleets)) {
				p.fleets.forEach(f => {
					objs.globalFleets.push(new Fleet(this, p, objs.factions[p.faction.name], f));
				});
			}
		}

		cache_connections(objs) {
			// Cache the start and end radians for jumps
			// Start and end radii can't be more than 90 degrees from the angle.
			var nc = [];
			var angles = [];
			var t = this;
			this.connections.forEach(function(c) {
				// build a list of angles
				var co = objs.systems[c];
				angles.push({name: c, angle: get_ang(pt_sub(co.location,t.location))});
				// cache the connection target
				nc.push(co);
			});
			this.connections = nc;
			// Sort the array of angles
			angles.sort(function(a,b) {
				return a.angle - b.angle;
			});
			let seAngles = [];
			if (angles.length>2) {
				for (let i=0; i<angles.length;i++) {
					let a = angles[i];
					let an = angles[(i+1)%angles.length];
					let ap = angles[i!=0?i:angles.length-1];
					let ax = ang_turnTowards(a.angle,an.angle,Math.PI);
					let ad = angDist(a.angle,an.angle);
					a.end = (ax[1])?a.angle+ad/2:a.angle+Math.PI/2;
					ax = ang_turnTowards(ap.angle,a.angle,Math.PI);
					ad = angDist(ap.angle,a.angle);
					a.start = (ax[1])?a.angle-ad/2:a.angle-Math.PI/2;
				}
				seAngles = angles;
			} else if (angles.length==2) {
				// Special case: ap==an
				let a0 = angles[0].angle;
				let a1 = angles[1].angle;
				let ad = angDist(a0,a1);
				let ac = ang_turnTowards(a0,a1,ad/2)[0];
				if (ac > a0 && ac < a0+Math.PI) {
					angles[0].end = angles[1].start = ac;
					angles[0].start = a0-Math.PI/2;
					angles[1].end = a1+Math.PI/2;
				} else {
					angles[0].start = angles[1].end = ac;
					angles[1].start = a1-Math.PI/2;
					angles[0].end = a0+Math.PI/2;
				}
				seAngles = angles;
			} else {
				seAngles = [{name:angles[0].name,start:angles[0].angle-Math.PI/2,end:angles[0].angle+Math.PI/2}]
			}
			// To enable simpler jump targeting, start is always < end.
			seAngles.forEach(a=>{
				if (a.start>a.end) {
					a.start -= 2*Math.PI;
				}
			});
			this.seAngles = seAngles;
		}

		load_planet(p, offset, objs) {
			p.location = pt_add(offset, pt(p.orbit, Math.random() * 2*Math.PI));
			var t = this;
			p.moons.forEach(function(m) {
				t.load_planet(m, p.location, objs);
			});
		}

		buildFleetElement(objs, f, sd, count) {
			let t = this;
			for (var i = 0; i < count; i++) {
				//
				var s = new Ship(sd, f.faction, f);
				// Spawn defensive fleets around the planet
				if (f.homeSystem == t) {
					s.location = pt_add(f.homeWorld.location, pt((f.homeWorld.radius + 100) * Math.random(), 2 * Math.PI*Math.random()));
				} else {
					if (f.prevSystem != t) {
						s.location = pt_add(pt(t.jumpRadius + 250 * Math.random(), get_ang(pt_sub(f.prevSystem.location, t.location))), pt((f.homeWorld.radius + 100) * Math.random(), 2 * Math.PI*Math.random()));
						s.angle = get_ang(pt_sub(t.location, f.prevSystem.location));
					} else {
						s.location = pt(t.sunRadius + 200 + Math.random()*(f.homeWorld.radius+100), Math.random()*Math.PI*2);
					}
				}
				s.angle = Math.random()*2*Math.PI;
				let tier = (sd.unmanned)?0:((sd.tier==-1)?0:-1);// Use T0 weapons to arm cargo ships and drones.
				f.faction.armShip(s, tier); 
				objs.ships.push(s);
			}
		}

		// Build the system
		buildSystem(objs, player, reloadLocs=true) {
			objs.ships = [];
			objs.projs = [];
			objs.fx = [];
			objs.fleets = objs.globalFleets.filter(f => f.location == this);
			objs.ships.push(player);
			// Set planet locations
			var t = this;
			this.planets.forEach(function(p) {
				if (!isdef(p.location) || reloadLocs==true) {
					t.load_planet(p, [0,0], objs);
				}
			});
			// Spawn in fleets
			objs.fleets.forEach(function(f){
				var tier = 0;
				f.shipCounts.forEach(function(c){
					t.buildFleetElement(objs, f, f.faction.shipTable[tier], c);
					tier += 1;
				});
				if (f.transports>0) {
					t.buildFleetElement(objs, f, f.faction.transportShip, f.transports);
				}
				
			});
		}

		// Enter the system
		// Initialize planet and ship locations
		enterSystem(objs, player) {
			// Set the player's previous location.
			player.prevSystem = player.location;
			//
			addMsg("Welcome to " + this.name + ".");
			// New system; clear everything but the player.
			player.location = pt(this.jumpRadius + 250 * Math.random(), get_ang(pt_sub(player.system.location, this.location)));
			player.system = this;
			 //
			this.buildSystem(objs, player);
		}

		// Find a path towards the nearest system, if any, that meets the specified criteria
		seekSystem(criteria, noHostile=false, incremental=true) { 
			// noHostile is the faction to avoid hostilities for
			// if incremental is false, returns the target system rather than the next system to navigate to to reach it.
			var links = {};
			var buf = [this];
			var t = this;
			while (buf.length != 0) {
				var buf2 = [];
				for (let i=0;i<buf.length;i++) {
					let s = buf[i];
					for (let j=0;j<s.connections.length;j++) {
						let c = s.connections[j];
						if (!isdef(links[c.name])) { // If we haven't encountered this system yet
							if (noHostile==false || !noHostile.checkHostileSystem(c)) {
								buf2.push(c);
							}
							links[c.name] = s;
							if (criteria(c)) {
								var target = c;
								if (incremental==false) {
									return target;
								}
								while (links[target.name] != t) {
									target = links[target.name];
								}
								return target;
							}
						}
					}
				}
				buf = buf2;
			}
			return false;
		}

		// For refreshing a system the player is already in.
		reloadSystem(objs, player) {
			player.prevSystem = this;
			this.buildSystem(objs, player, false);
		}

		renderPlanet(p, context, offset, objs) {
			var t = this;
			context.strokeStyle = (p.faction==false)?planetColor:p.faction.color;
			context.beginPath();
			context.arc(offset[0] + p.location[0], offset[1] + p.location[1], p.radius, 0, 2*Math.PI);
			context.stroke();
			if (objs.player.landingTarget == p) {
				context.strokeStyle = (p.initialFaction == false || p.faction.getRelationship(objs.player.faction) >= 0)?objs.player.faction.color:'#FF0000';
				context.beginPath();
				context.arc(offset[0] + p.location[0], offset[1] + p.location[1], p.radius+20, 0, 2*Math.PI);
				context.stroke();
			}
			p.moons.forEach(function(m) {
				t.renderPlanet(m, context, offset, objs);
			});
		}	

		render(context, c_loc, objs) {
			var t = this;
			var offset = pt_sub([0,0], c_loc);
			// 
			let sAdj = [screenWidth/2,screenHeight/2];
			let sLoc = pt_sub(sAdj, pt_mul(pt_add(c_loc, sAdj), starParallax));
			// Render sun
			context.strokeStyle = context.fillStyle = this.sunColor+'AA';
			context.shadowBlur = 150;
			context.shadowColor = this.sunColor;
			context.beginPath();
			context.arc(...sLoc, this.sunRadius, 0, 2*Math.PI);
			context.fill();
			context.shadowBlur = 0;
			// Render jump radius
			context.strokeStyle = jumpRadiusColor+'77';
			context.beginPath();
			context.arc(offset[0], offset[1], this.jumpRadius, 0, 2*Math.PI);
			context.stroke();
			// Render RKV lock radius
			context.strokeStyle = killRadiusColor+'77';
			context.beginPath();
			context.arc(offset[0], offset[1], this.killRadius, 0, 2*Math.PI);
			context.stroke();
			// Render planets
			this.planets.forEach(function(p) {
				t.renderPlanet(p, context, offset, objs);
			});
		}

		updatePlanet(p, objs) {
			var t = this;
			var dist = get_mag(pt_sub(p.location, objs.player.location));
			if (dist < p.radius) {
				objs.player.landingTarget = p;
			}
			p.moons.forEach(m => {
				t.updatePlanet(m, objs);
			});
		}

		update(objs) {
			var t = this;
			// Damage ships that are flying too close to the sun
			objs.ships.forEach(s=>{
				let locMag = get_mag(s.location);
				if (locMag < this.sunKillRadius) {
					s.health -= 100 * (1 - locMag / (this.sunKillRadius));
				}
			});
			// Handle jumping
			player.jumpTarget = false;
			let playerAng = get_ang(player.location);
			if (get_mag(player.location) > this.jumpRadius) {
				this.seAngles.forEach(function(a){
					if (playerAng >= a.start && playerAng < a.end || 
						(a.end > 2*Math.PI && (playerAng < a.end-2*Math.PI)) || //  last angle's end could exceed 2pi
						(a.start < 0 && (playerAng > a.start + 2*Math.PI))) { // First angle's start could be negative
						player.jumpTarget = objs.systems[a.name];
					}
				});
			}
			// Handle landing
			objs.player.landingTarget = false;
			this.planets.forEach(p =>{
				t.updatePlanet(p, objs);
			});
		}

	}
</script>

<!-- Initialization -->
<script type="text/javascript">
	var canvas, screenWidth, screenHeight;
	var keysDown = [];
	var leftMouseDown = false;
	var rightMouseDown = false;
	var mousePos = [0,0]; // Adjusted mouse position; 0,0 is the center of the screen.
	const W_KEY = 87;
	const A_KEY = 65;
	const S_KEY = 83;
	const D_KEY = 68;
	const UP_KEY = 38;
	const LEFT_KEY = 37;
	const DOWN_KEY = 40;
	const RIGHT_KEY = 39;
	const E_KEY = 69;
	const SPACE_KEY = 32;

	// System variables
	var system = null;
	var player = null;
	var date = 0;
	var playerLanded = false;
	var msgBuf = [];
	var objs = {
		// Player
		player: null,
		// Local
		ships: [],
		projs: [],
		fleets: [],
		fx: [], // For both kinds of effects.
		// Global
		globalFleets: [],
		systems: {},
		factions: {},
		events: {},
		// Changes that occur, broadcasted when the universe changes
		univChanges: {
			factionChanges: {}// Stored as alphabetical pairings mapped to the signs of the initial and final relationships. "FactionA and FactionB": [1, -1]
		}
	};
	var starfield;

	// Event variables
	var event;
	var eventVar=0;

	// Interception variables
	var interceptionSystem; // The pseudo-system in which interceptions are handled
	var interceptionFleets; // The fleets that are (along with the player) in the interception system.

	// Menu variables
	var currentMenu;
	const MAIN_MENU = 0;
	const BUY_SHIP = 1;
	const SELECT_SLOT = 2;
	const BUY_WEAPON = 3;
	var menuPosition;
	var menuConfirm = false;
	var menuOptions;

	// Menu visual constants
	const menuBackgroundColor = '#00000088';
	const menuWidth = 800;
	const menuHeight = 500;
	const sidebarWidth = 250;
	const menuFontSize = 20; 
	const menuFont = menuFontSize + 'px consolas';

	// Gameplay constants
	const shipCosts = [.5,1,3,10]; // Industry costs for each ship type.
	const restrictPlayerFire = false;
	const MAXJUMPDELAY = 150;
	const MAX_INDUSTRY = 10;
	const startingShipTier = 1;

	// Visual constants
	const jumpRadiusColor = '#FFFF00';
	const killRadiusColor = '#FF0000';
	const planetColor = '#AAAAAA';
	const msgFontSize = 10; 
	const msgFont = msgFontSize + 'px consolas'
	const msgBufSize = 10;
	const minimapOpacityPhysical = 85;
	const minimapOpacityVirtual = 37;
	const minimapScale = 40;
	const starmapScale = 2;
	const gridParallax = .5;
	const starParallax = .75;

	window.getAnimationFrame =
	window.requestAnimationFrame ||
	window.webkitRequestAnimationFrame ||
	window.mozRequestAnimationFrame ||
	window.oRequestAnimationFrame ||
	window.msRequestAnimationFrame ||
	function(callback)
	{
		window.setTimeout(callback, 16.6);
	};

	window.onload = function()
	{
		canvas = document.getElementById('canvas');
		context = canvas.getContext('2d');

		window.onresize();

		initControls();

		initGame();

		loop();
	};
</script>

<!--

	Gameplay

-->
<script type="text/javascript">
	function initGame() {
		// This is going to be where the testing code goes for the forseeable future.
		FACTIONS_DATA.forEach(function(f) {
			new Faction(f, objs);
		});
		// Initialize systems
		SYSTEMS_DATA.forEach(function(s) {
			new System(objs, s);
		});
		for (s in objs.systems) {
			objs.systems[s].buildConnections(objs);
		}
		for (s in objs.systems) {
			objs.systems[s].cache_connections(objs);
		}
		// Initialize events
		EVENTS_DATA.forEach(function(e) {
			objs.events[e.name] = e;
		});
		setPlayerShip(objs.factions['Player'].shipTable[0]);
		objs.player = player;
		
		/*
		let sf = 'Grey Republic';
		objs.factions[sf].armShip(player);
		player.regen=100;
		player.weaponSlots[1].weapon.rof=1;
		player.weaponSlots[1].arc = Math.PI*2;
		player.weaponSlots[1].weapon.reloadRate=1;
		player.weaponSlots[1].weapon.incReload=false;
		player.weaponSlots[1].weapon.projectile.damage = 1000;
		player.max_vel=7;

		player.faction.setRelationship(objs.factions['Golden Empire'],-1);
		//*/
		objs.ships.push(player);
		// Update the universe
		updateUniverse(objs);
		//
		player.system = objs.systems["Vagrant"]; // Because enterSystem places the player on his entry vector.
		objs.systems['Vagrant'].enterSystem(objs, player);
		// Call up the start event
		startEvent('startEvent');
	}

	function setPlayerShip(shipType) {
		let ix = objs.ships.indexOf(player);
		let sys;
		let loc;
		if (ix != -1) {
			objs.ships.splice(ix,1);
			sys = player.system;
			loc = player.location;
		}
		objs.player = player = new Ship(shipType, objs.factions['Player'], false);
		player.player = true;
		if (ix != -1) {
			player.system = sys;
			player.location = loc;
		}
		objs.ships.push(player);
	}

	function addMsg(msg) {
		msgBuf.splice(0,0,msg);
		if (msgBuf.length == msgBufSize) {
			msgBuf.splice(msgBuf.length-1,1);
		}
	}

	function getFactionPresence(f, s) {
		let presence = false;
		s.planets.forEach(p=>{
			presence = presence || (p.faction==f);
		});
		return presence;
	}

	function handleSubfactionSpawning(objs) {
		Object.keys(objs.factions).forEach(f=>{
			f=objs.factions[f];
			f.subfactions.forEach(sf=>{
				sf = objs.factions[sf];
				// Growth rate
				if (Math.random()<sf.growthRate-sf.colonies*sf.decayRate) { // temporarily set spawnrate to 1
					// Get the set of owned systems, then, if it's empty, the set of main faction systems
					let ss = objs.systems;
					let syst = Object.keys(ss).filter(s=>getFactionPresence(sf,ss[s]));
					if (syst.length==0) { syst=Object.keys(ss).filter(s=>getFactionPresence(f,ss[s])); }
					if (syst.length!=0) {
						// Pick a random system from the list
						let i = Math.floor(Math.random()*syst.length);
						let s = objs.systems[syst[i]];
						// Seek an empty system that this faction can survive in
						let criteria = function(x) { // Has habitable planet and has no current presence
							let habFound = false;
							if (!x.generated) {return false;} // Don't spawn subfactions in systems I've left empty for a good reason.
							if (player.system==x) { return false; } // Don't spawn anything into the player's system.
							let emptySystem=true;
							x.planets.forEach(p=>{
								if (p.faction!=false) { emptySystem=false; }
								if (sf.habitable(p,x)) {
									habFound=true;
								}
							});
							return (habFound&&emptySystem);
						}
						let ts = s.seekSystem(criteria, sf, false);
						if (ts) {
							let ps = ts.planets.filter(p=>(sf.habitable(p,ts)));
							let targetPlanet = ps[Math.floor(Math.random()*ps.length)];
							// Colonize the target planet
							console.log('A subfaction built a settlement in ' + ts.name);
							sf.colonies++;
							targetPlanet.faction = sf;
							targetPlanet.industrialCapacity = sf.baseProductivity;
							// Build a defensive fleet
							let f = { defensive: 1, shipCapacities: [0,0,0]}
							let budget = sf.baseIndustry;
							while (budget>=shipCosts[0]) {
								let options = []
								for (let i=0;i<shipCosts.length;i++) {
									if (shipCosts[i]<=budget) {
										options.push(i);
									}
								}
								let choice = options[Math.floor(Math.random()*options.length)];
								budget-=shipCosts[choice];
								f.shipCapacities[choice]+=1;
							}
							objs.globalFleets.push(new Fleet(ts, targetPlanet, sf, f));
						}
					}
				}
			});
		});
	}

	function handleFleetActions(objs) {
		//
		let pst = (player.prevSystem)?[player.system.name, player.prevSystem.name].sort().join():'';
		//
		objs.globalFleets.forEach(f => { f.fought=false; f.prevSystem=f.location; });
		// Resolve battles before handling movement
		objs.globalFleets.forEach(f => { f.handleBattles(objs); });
		// Get the starting system of each fleet.
		let startingSystems = {};
		objs.globalFleets.forEach(f => {
			let n = f.location.name;
			if (isdef(startingSystems[n])) {
				startingSystems[n].push(f);
			} else {
				startingSystems[n] = [f];
			}
		});
		// Move fleets
		objs.globalFleets.forEach(f => { if (!f.fought) { f.update(objs); } });
		//  Resolve ending systems
		let systemTransitions = {};
		Object.keys(startingSystems).forEach(ss => {
			startingSystems[ss].forEach(f=>{ // For each fleet originating from this system
				let n = f.location.name;
				let st = [n, ss].sort().join();
				if ((n == ss) || (!f.hasShips())) {
					// Ignore fleets that did not move or are empty.
				} else if (isdef(systemTransitions[st])) {
					if (st != pst) { // If the player isn't traveling the same route, auto-resolve.
						systemTransitions[st].forEach(of=>{
							if ((f.faction.getRelationship(of.faction)<0) && (f.hasShips())) { // Intercept hostile fleet
								f.attackFleet(of);
							}
						});
					}
					systemTransitions[st].push(f);
				} else {
					systemTransitions[st] = [f];
				}
			});
		});
		// Handle player system transitions
		// For now, simply prevent hostile fleets from leapfrogging the player.
		if (isdef(systemTransitions[pst])) {
			console.log('Blocked: ' + ststemTransitions[pst]);
			systemTransitions[pst].forEach(f=>{
				if (f.faction.getRelationship(player.faction)<0) {
					f.location = f.prevSystem;
				}
			});
		}
	}


	function updateUniverse(objs) {
		// 
		date += 1;
		addMsg('-~= DAY ' + date + ' =~-');
		//
		handleFleetActions(objs);
		//
		for (var n in objs.systems) {
			var s = objs.systems[n];
			// Get the set of fleets in the system
			sf = objs.globalFleets.filter(f => f.location==s);
			// Each planet generates some industry
			s.planets.forEach(p => {
				// Conquered planets are less productive
				let inc = (p.faction.name == p.initialFaction)?p.industrialCapacity:p.industrialCapacity/2;
				p.storedIndustry = Math.min(p.storedIndustry + inc, MAX_INDUSTRY);
				p.saveIndustry = false;
			});
			// Each fleet gets to restock from its homeworld, if in the same system.
			sf.forEach(f => {
				if (f.homeSystem == s) {
					var p = f.homeWorld;
					if (p.faction==f.faction) {
						let saveIndustry = false;
						res = f.restock(p.storedIndustry);
						p.storedIndustry = res[0];
						saveIndustry = res[1];
						p.saveIndustry = (p.saveIndustry || saveIndustry);
					}
				}
			});
			// The remaining industry is used to regenerate any remaining fleets in the system.
			sf.forEach(f => {
				s.planets.forEach(p => {
					if (p.saveIndustry == false&&p.faction==f.faction) {
						p.storedIndustry = f.restock(p.storedIndustry)[0];
					}
				});
			});
		}
		// Handle subfaction spawning
		handleSubfactionSpawning(objs);
		// Finally, broadcast changes to the universe
		let fc = objs.univChanges.factionChanges;
		Object.keys(fc).forEach(c=>{
			if ((fc[c][0]!=fc[c][1]) && (fc[c][0]+fc[c][1]!=1)) { // If the relationship has changed. Don't broadcast positive=>neutral or neutral=>positive changes.
				let fRel = (fc[c][1]<0)?'enemies.':'allies.';
				addMsg(c + " are now " + fRel);
			}
		});
		objs.univChanges.factionChanges = {}; 
	}

	function renderMap(objs, player, sys, context) {
		//
		let size = 100;
		let scale = starmapScale;
		let offset = 100;
		let inRange = get_mag(player.location) > sys.jumpRadius;
		context.strokeStyle = inRange ? '#FFFFFF99' : '#FFFFFF55';
		// Scale down the galactic map and display it
		let base = [screenWidth-offset-size/2, screenHeight-offset-size/2]
		context.beginPath();
		context.arc(base[0],base[1],3,0,2*Math.PI);
		context.stroke();
		sys.connections.forEach(function(s) {
			context.beginPath();
			let loc = [s.location[0]-sys.location[0], s.location[1]-sys.location[1]];
			context.arc(base[0]+loc[0]/scale,base[1]+loc[1]/scale,2,0,2*Math.PI);
			context.stroke();
			// Show the connections
			if (inRange) {
				context.beginPath();
				context.strokeStyle='#FFFFFF33';
				context.moveTo(base[0], base[1]);
				context.lineTo(base[0]+loc[0]/scale,base[1]+loc[1]/scale);
				context.stroke();
			}
		});
		// Show the player's position
		if (inRange) {
			var temp = pt(15, get_ang(player.location));
			context.beginPath();
			context.strokeStyle='#FFFFFF55';
			context.moveTo(base[0], base[1]);
			context.lineTo(base[0]+temp[0],base[1]+temp[1]);
			context.stroke();
		}
		// Show the angles
		let playerAng = get_ang(player.location);
		if (get_mag(player.location) > sys.jumpRadius) {
			sys.seAngles.forEach(function(a){
				context.beginPath();
				if (player.jumpTarget == objs.systems[a.name]) { // First angle's start could be negative
					context.strokeStyle = '#FFFFFF';
				} else {
					context.strokeStyle = '#FFFFFF33';
				}
				context.arc(base[0],base[1],10,a.start,a.end);
				context.stroke();
			});
		}
		//
	}

	function renderMessages(context) {
		var offset = 100; // Distance from the lower left corner
		var color = '#FFFFFF';
		context.font = msgFont;
		for (var i=0;i<msgBuf.length;i++) {
			context.fillStyle = color + Math.round(10+80*(msgBufSize-i)/msgBufSize);
			context.fillText(msgBuf[i], offset, screenHeight-offset-msgFontSize*i);
		}
	}

	function drawPlanetScale(context, p, s, b, o) {
		context.strokeStyle =(p.faction==false?planetColor:p.faction.color)+o;
		context.beginPath();
		let l = pt_add(b, pt_mul(p.location, s));
		context.arc(l[0],l[1],p.radius*s,0,2*Math.PI);
		context.stroke();
		if (p.moons) {
			p.moons.forEach(m=>{drawPlanetScale(context,m,s,b,o);});
		}
	}

	function renderMinimap(objs, player, sys, context) {
		let scale = 1/minimapScale;
		let size = sys.jumpRadius*scale;
		let offset = 100;
		let opacity = toHex(minimapOpacityPhysical);
		let opacity2 = toHex(minimapOpacityVirtual);
		// Display:
		let base = [offset+size/2, offset+size/2];
		// Planets
		let pl = player.location;
		sys.planets.forEach(function(p) {
			/*
			context.strokeStyle =(p.faction==false?planetColor:p.faction.color)+opacity;
			context.beginPath();
			var l = pt_sub(p.location,pl);
			context.arc(base[0]+l[0]*scale,base[1]+l[1]*scale,p.radius*scale,0,2*Math.PI);
			context.stroke();//*/
			drawPlanetScale(context,p,scale,pt_sub(base, pt_mul(pl, scale)),opacity);
		});
		// Sun
		context.fillStyle = '#FFFFFF'+opacity;//sys.sunColor+opacity;
		let l = pt_sub([0,0],pl);
		context.beginPath();
		context.arc(base[0]+l[0]*scale,base[1]+l[1]*scale,sys.sunRadius*scale,0,2*Math.PI);
		context.fill();
		// Jump and kill radii
		context.strokeStyle = '#FFFFFF'+opacity2;//jumpRadiusColor+opacity2;
		context.beginPath();
		context.arc(base[0]+l[0]*scale,base[1]+l[1]*scale,sys.jumpRadius*scale,0,2*Math.PI);
		context.stroke();
		context.strokeStyle = '#FFFFFF'+opacity2;//killRadiusColor+opacity2;
		context.beginPath();
		context.arc(base[0]+l[0]*scale,base[1]+l[1]*scale,sys.killRadius*scale,0,2*Math.PI);
		context.stroke();	
		// Ships
		objs.ships.forEach(function(s) {
			context.strokeStyle = s.color+opacity;
			context.beginPath();
			l = pt_sub(s.location,pl);
			context.arc(base[0]+l[0]*scale,base[1]+l[1]*scale,s.radius*scale,0,2*Math.PI);
			context.stroke();
		});
	}

	function renderPlayerHUD(context, player) {
		let offsetX = 100;
		let offsetY = 50;
		let opacity = toHex(minimapOpacityVirtual);
		let wdw = 10; // Weapon display width
		let wdh = 50; // Weapon display height
		let wds = 5; // Weapon display spacing
		let hbh = 5;
		let sfw = 5;
		//
		let base = [screenWidth-offsetX, offsetY];
		let temp = 0;
		let pm = get_mag(player.location);
		let c = ((pm>player.system.killRadius||pm<player.system.sunKillRadius+100) && Math.random()>0.5)?'#FF0000':player.faction.color;
		context.fillStyle = c+opacity;
		// Weapon displays
		player.weaponSlots.forEach(s=>{
			if (s.weapon) {
				let w = s.weapon;
				let f = w.clipAmmo/w.clipSize;
				if (w.clipSize==1 || w.clipSize > wdh/2) {
					context.fillRect(base[0]-temp,base[1],wdw,wdh); // Background
					context.fillRect(base[0]-temp,base[1]+wdh*(1-f),wdw,wdh*f); // Ammo loaded
				} else {
					let h = (wdh-w.clipSize)/w.clipSize;
					let o = 0;
					for (let i=0; i<w.clipSize; i++) {
						if (i>=w.clipSize-w.clipAmmo) { context.fillStyle=c+toHex(minimapOpacityVirtual*2); }
						context.fillRect(base[0]-temp,base[1]+o,wdw,h);
						
						o+=h+1;
					}
					context.fillStyle = c+opacity;
				}
				if (w.incReload) {
					f = Math.min(1, f+((w.reloadProg/w.reloadRate)/w.clipSize));
				} else {
					f = Math.min(1, (w.reloadProg/w.reloadRate));
				}
				context.fillRect(base[0]-temp,base[1]+wdh*(1-f),wdw/2,wdh*f); // Reload progress
			} else {
				let c = context.fillStyle;
				context.fillStyle = '#FF0000'+opacity
				context.fillStyle = c;
			}
			temp += wdw + wds;
		});
		temp -= (wdw + wds);
		// Health bar is as wide as the weapon display
		context.fillRect(base[0]-temp, base[1]+wdh+wds, temp+wdw, hbh);
		context.fillRect(base[0]-temp, base[1]+wdh+wds, (temp+wdw)*player.health/player.maxHealth, hbh);
		// Strafe fuel indicator
		if (player.strafe) {
			temp += (wds+sfw);
			let sfh = wds+hbh+wdh;
			context.fillRect(base[0]+wdw+wds, base[1], sfw, sfh);
			context.fillRect(base[0]+wdw+wds, base[1]+sfh*(1-player.strafeFuel/player.maxStrafeFuel), sfw, sfh*(player.strafeFuel/player.maxStrafeFuel));
			if (player.strafeCharge!=player.strafeReload) {
				context.fillRect(base[0]+wdw+wds, base[1]+sfh*(1-player.strafeCharge/player.strafeReload), sfw, sfh*(player.strafeCharge/player.strafeReload));
			}
		}
		// Indicators
		let ix = screenWidth/2;
		let iy = screenHeight/2-200;
		context.font = menuFont;
		// Jump indicator
		if (player.jumpDelay==0&&player.jumpTarget) {
			let t = "HOLD 'E' TO JUMP TO " + player.jumpTarget.name.toUpperCase();
			context.fillStyle = '#FFFFFF55';
			context.fillText(t,ix-context.measureText(t).width/2,iy);
			iy += menuFontSize;
		}
		// Land indicator
		if (player.landingTarget && (!playerLanded)) {
			let canLand = (player.landingTarget.initialFaction==false) || (player.landingTarget.faction.getRelationship(player.faction)>=0);
			let t = (canLand?"HOLD 'E' TO LAND ON ":"ENEMY PRESENCE PREVENTS LANDING ON ") + player.landingTarget.name.toUpperCase();
			context.fillStyle = '#FFFFFF55';
			context.fillText(t,ix-context.measureText(t).width/2,iy);
			iy += menuFontSize;
		}
		// RKV lock indicator
		if (pm>player.system.killRadius) {
			let t = "WARNING: RELATIVISTIC KILL VEHICLE LOCK";
			context.fillStyle = '#FF000055';
			context.fillText(t,ix-context.measureText(t).width/2,iy);
			iy += menuFontSize;
		}
		// Sun indicator
		if (pm<player.system.sunKillRadius+100) {
			let t = "HEAT WARNING";
			context.fillStyle = '#FF000055';
			context.fillText(t,ix-context.measureText(t).width/2,iy);
			iy += menuFontSize;
		}
		// Show RKV lock
		if (player.rkv_time != player.rkv_max) {
			var l = [screenWidth/2,screenHeight/2];
			context.strokeStyle = (get_mag(player.location) > player.system.killRadius)?'#FF0000':'#FF000055';
			let temp = context.lineWidth;
			context.beginPath();
			if (player.rkv_angle < 0) {
				context.arc(l[0], l[1], player.rkv_time/player.rkv_max * (screenWidth+screenHeight), 0, 2*Math.PI);
			}
			context.stroke();
			context.lineWidth = temp;
		}
	}

	const sfSize=2000;
	function generateStarfield() {
		starfield = [];
		for (let i=0; i<200; i++) {
			starfield.push([Math.random()*sfSize, Math.random()*sfSize, Math.random()]);
		}
	}

	function drawStars(context, cm, par) {
		if (!starfield) {generateStarfield();}
		// For now, a wrapping starfield with no depth.
		context.fillStyle = '#888888';
		starfield.forEach(s=>{
			let x = (s[0]-(cm[0]*s[2])%sfSize)%sfSize;
			let y = (s[1]-(cm[1]*s[2])%sfSize)%sfSize;
			if (x<0) {x+=sfSize;}
			if (y<0) {y+=sfSize;}
			context.beginPath();
			context.arc(x,y,1,0,2*Math.PI);
			context.fill();
		});
	}

	function drawGrid(context, cm) {
		drawStars(context,cm);
		drawStars(context,cm);
		//*
		var grid_size = 100;
		var parallax = 0.5
		context.strokeStyle = '#222222';
		for (var gp=screenWidth-(cm[0]*parallax)%grid_size; gp>0;gp-=grid_size) {
			context.beginPath();
			context.moveTo(gp,0);
			context.lineTo(gp,screenHeight);
			context.stroke();
		}
		for (var gp=screenHeight-(cm[1]*parallax)%grid_size; gp>0;gp-=grid_size) {
			context.beginPath();
			context.moveTo(0,gp);
			context.lineTo(screenWidth,gp);
			context.stroke();
		}
		//*/
	}

	function drawCRT(context) {
		let temp = context.lineWidth;
		context.lineWidth = 1;
		for (var gp=0; gp<=screenHeight;gp+=4) {
			context.strokeStyle = (Math.random()>.0001)?'#FFFFFF10':'#22222210';
			context.beginPath();
			context.moveTo(0,gp);
			context.lineTo(screenWidth,gp);
			context.stroke();
		}
		context.lineWidth = temp;
	}

	function keyPress(kc) {
		if (event != false) {
			if (kc == D_KEY || kc == RIGHT_KEY) {
				eventVar += 1;
			} else if (kc == A_KEY || kc == LEFT_KEY) {
				eventVar -= 1;
			} else if (kc == W_KEY || kc == UP_KEY) {
				concludeEvent(event);
			}
		} else if (playerLanded != false) {
			if (kc == S_KEY || kc == DOWN_KEY) {
				menuConfirm = false;
				menuPosition = (menuPosition+1)%menuOptions.length;
			} else if (kc == W_KEY || kc == UP_KEY) {
				menuConfirm = false;
				menuPosition = menuPosition!=0?menuPosition-1:menuOptions.length-1;
			} else if (kc == D_KEY || kc == RIGHT_KEY) {
				if (menuConfirm == true) {
					menuConfirm = false;
				} else {
					menuOptions[menuOptions.length-1].function();
				}
			} else if (kc == A_KEY || kc == LEFT_KEY) {
				var f = menuOptions[menuPosition].function;
				if (f != null) {
					f();
				}
			}
		}
	}

	function planetMainMenu() {
		currentMenu = MAIN_MENU;
		menuPosition = menuConfirm = 0;
		var f=playerLanded.faction;
		// Main description
		let mainDesc = ((playerLanded.initialFaction==false)||(playerLanded.faction.name==playerLanded.initialFaction))?playerLanded.desc:playerLanded.faction.conquestText;
		// Handle colonies
		if (playerLanded.initialFaction==false && playerLanded.faction!=false) {
			let cf = playerLanded.faction;
			mainDesc += ' ';
			if (player.system.isCold(playerLanded)) {
				mainDesc += cf.coldDesc;
			} else if (player.system.isHot(playerLanded)) {
				mainDesc += cf.hotDesc;
			} else {
				mainDesc += cf.temperateDesc;
			}
			mainDesc += " An armed vessel that didn't have to worry about defenders could destroy this asset.";
		}
		//
		menuOptions = [
			{
				text: "Main",
				function: null,
				desc: mainDesc
			},
			{
				text: "Switch Ship",
				function: (playerLanded.initialFaction==false?null:function(){
					planetBuyShip();
				}),
				desc: "Request a new ship from the planet's government."
			},
			{
				text: "Install Weapon",
				function: (playerLanded.faction==false?null:function(){
					planetSelectSlot();
				}),
				desc: "Change your ship's weapon configuration."
			}
			
		];
		// If there's a base on this planet that can be destroyed, add another menu option
		if (playerLanded.faction!=false && playerLanded.initialFaction==false) {
			let playerWpn = false;
			player.weaponSlots.forEach(w=>{ playerWpn=w.weapon||playerWpn; });
			let defenders = objs.ships.filter(x=>x.faction==playerLanded.faction)
			if (playerWpn!=false && defenders.length==0) {
				menuOptions.push({
					text: "Raze Installation", // Pressing 'left' runs the last menu option's function
					function: function(){
						// Raze the installation
						let p = playerLanded;
						let c = playerLanded.faction.color;
						addMsg('You level the facility on '+ p.name +' and immediately leave the area.');
						playerLanded.faction.handleAssetLost(objs, p.faction.baseIndustry*2, player.faction);
						playerLanded.faction = false;
						playerLanded.industrialCapacity = 0;
						playerLanded.storedIndustry = 0;
						playerLanded.faction.colonies--;	
						// Standard takeoff procedure.
						updateUniverse(objs);
						player.system.reloadSystem(objs,player);
						player.location = playerLanded.location.slice();
						playerLanded = false;
						// Add an explosion at altitude 50 somewhere on the planet
						// (loc, velocity, radius, deltaRad, color,life,altitude=100)
						objs.fx.push(new CircleEffect(pt_add(p.location,pt(p.radius*Math.random(),Math.random()*2*Math.PI)),[0,0],40+Math.random()*40,Math.random()*5,c,50+Math.random()*50, 50));
					},
					desc: "Lift off, destroying the " + playerLanded.faction.name + " presence on this planet on your way out."
				});
			}
		}
		// Add the last menu option. This has to be the last because the right key defaults to it.
		menuOptions.push({
			text: "Take off", // Pressing 'left' runs the last menu option's function
			function: function(){
				updateUniverse(objs);
				player.system.reloadSystem(objs,player);
				player.location = playerLanded.location.slice();
				playerLanded = false;
			},
			desc: "Lift off and return to the stars."
		});
	}

	function planetBuyShip(objs) {
		currentMenu = BUY_SHIP;
		menuPosition = menuConfirm = 0;
		var f=playerLanded.faction;
		menuOptions = [{
			text: "Current Ship",
			ship: player,
			function: null
		}]; 
		var tf = new Array(shipCosts.length).fill(0);
		playerLanded.fleets.forEach(f=>{
			for (var i=0;i<f.shipCapacities.length;i++){
				tf[i] += f.shipCapacities[i];
			}
		});
		// Options: Current ship, all faction ships in faction table, exit 
		var rel = player.faction.getRelationship(playerLanded.faction);
		for (let i=0;i<tf.length;i++) {	
			if (tf[i] > 0 && (!playerLanded.faction.shipTable[i].unmanned)) {
				let sn = playerLanded.faction.shipTable[i].name;
				let cost = shipCosts[i] * 15;
				let s = playerLanded.faction.shipTable[i];
				menuOptions.push({
					text: sn,
					ship: s, // What ship can we buy here?
					cost: cost,
					function: ((rel<cost)?null:function(){
						if (menuConfirm == true) {
							// Buy the ship and return to the menu
							setPlayerShip(s);
							player.altitude = 0;
							player.jumpDelay=0;
							planetMainMenu();
							player.faction.adjRelationship(objs, playerLanded.faction, -cost);
							//
							addMsg('Acquired a ' + s.name + '.');
						} else {
							menuConfirm = true;
						}
					})
				});
			}
		}
		//
		menuOptions.push({
			text: "Back",
			function: function(){
				planetMainMenu();
			},
		});
	}

	function planetSelectSlot() {
		currentMenu = SELECT_SLOT;
		menuPosition = menuConfirm = 0;
		var f=playerLanded.faction;
		menuOptions = []; 
		// Options: Current ship, all faction ships in faction table, exit 
		var rel = player.faction.getRelationship(playerLanded.faction);
		primarySlots = 0;
		secondarySlots = 0;
		for (var i=0;i<player.weaponSlots.length;i++) {
			let i2 = i;
			let slot = player.weaponSlots[i2];
			menuOptions.push({
				text: (slot.secondary?'Secondary slot '+(++secondarySlots):'Primary slot '+(++primarySlots)),
				slot: slot,
				function: function() {
					// Select this slot and move to the weapon purchase screen.
					planetBuyWeapon(objs, slot);
				}
			});
		}
		//
		menuOptions.push({
			text: "Back",
			function: function(){
				planetMainMenu();
			}
		});
	}

	function planetBuyWeapon(objs, slot) {
		currentMenu = BUY_WEAPON;
		menuPosition = menuConfirm = 0;
		var f=playerLanded.faction;
		menuOptions = []; 
		// Options: Current ship, all faction ships in faction table, exit 
		var rel = player.faction.getRelationship(playerLanded.faction);
		var wpnList = (slot.secondary)?f.weaponTable.secondary:f.weaponTable.primary;
		for (let i=0;i<wpnList.length;i++) {
			let wpn = wpnList[i];
			let rel = player.faction.getRelationship(f);
			menuOptions.push({
				text: wpn.name,
				wpn: wpn,
				cost: wpn.cost,
				function: ((rel<wpn.cost) || (rel==0))?null:function() {
					if (menuConfirm==true) {
						// Equip the weapon in the chosen slot
						slot.installWeapon(new Weapon(wpn));
						addMsg('Installed ' + wpn.name + ".");
						//
						player.faction.adjRelationship(objs, f,-wpn.cost);
						// Back
						planetSelectSlot();
					} else {
						menuConfirm = true;
					}
				}
			});
		}
		//
		menuOptions.push({
			text: "Back",
			function: function(){
				planetSelectSlot();
			}
		});
	}

	function drawTextBlock(ctx,x,y,w,h,text,fs) {
		let sentences = [];
		let words = text.split(' ');
		let cur = "";
		words.forEach(wd=>{
			let temp = cur+" "+wd;
			if (ctx.measureText(temp).width > w) { // If we exceed the maximum width, continue.
				sentences.push(cur);
				cur = "";
			}
			cur += " "+wd;
		});
		sentences.push(cur);
		th = 0;
		for (let i=0;i<sentences.length;i++) {
			let s = sentences[i];
			ctx.fillText(s,x,y+th);
			th+=fs;
			if (th>h) { return sentences.slice(i+1); }
		}
		return [];
	}

	function displayMainMenu(context,x,w,y,h,c) {
		let o = menuOptions[menuPosition];
		// Planet name, image, description
		let color = context.strokeStyle = context.fillStyle = c;
		// Header
		y+=menuFontSize;
		context.fillText(playerLanded.name,x+10,y);
		y+=5;
		context.beginPath();
		context.moveTo(x, y);
		context.lineTo(x+w,y);
		context.stroke();
		// Image
		/*
		context.beginPath();
		context.arc(x+w/2,y+h/6,h/6,0,2*Math.PI);
		*/
		// Sun
		let s = player.system;
		let center = [x+w/2, y+h/6];
		let imgScale = (h/6-15)/s.killRadius;
		context.fillStyle = playerLanded.sunColor;
		context.beginPath();
		context.arc(center[0],center[1],s.sunRadius*imgScale,0,2*Math.PI);
		context.fill();
		// Planets
		player.system.planets.forEach(p=>{
			drawPlanetScale(context, p, imgScale, center, '');
		});
		context.strokeStyle='#FFFFFF';
		context.beginPath();
		context.arc(...pt_add(center,pt_mul(playerLanded.location,imgScale)),playerLanded.radius*imgScale+5,0,2*Math.PI);
		context.stroke();
		// Adjust position
		context.strokeStyle = color;
		y += h/3;
		context.moveTo(x, y);
		context.lineTo(x+w,y);
		context.stroke();
		// Description
		y+=menuFontSize;
		let text = o.function==null?menuOptions[0].desc:o.desc;
		//
		drawTextBlock(context,x,y,w-10,(2*h/3-menuFontSize*2),text,menuFontSize);
	}

	function displayBuyShip(context,x,w,y,h,c) {
		// Ship name, image, description
		context.strokeStyle = context.fillStyle = c;
		var o = menuOptions[menuPosition];
		// Header
		y+=menuFontSize;
		context.fillText((o.cost)?(o.text+' ['+o.cost+']'):o.text,x+10,y);
		y+=5;
		context.beginPath();
		context.moveTo(x, y);
		context.lineTo(x+w,y);
		context.stroke();
		// Image
		if (isdef(o.ship)) {
			var adj = [x+w/2,y+h/6];
			context.moveTo(...o.ship.shape[0]);
			context.beginPath();
			o.ship.shape.forEach(p =>{
				context.lineTo(...pt_add(p, adj));
			});
			context.stroke();
			// Display weapon slots
			o.ship.weaponSlots.forEach(s =>{
				var loc = pt_add(s.location, adj);
				context.strokeStyle = '#FF0000AA';
				context.beginPath();
				context.arc(loc[0],loc[1], (s.secondary)?5:2, 0, 2*Math.PI);
				context.stroke();
				context.beginPath();
				context.arc(loc[0], loc[1], 10, s.angle - s.arc, s.angle + s.arc);
				context.stroke();
			});
			context.strokeStyle = c;
		}
		y += h/3;
		context.beginPath();
		context.moveTo(x, y);
		context.lineTo(x+w,y);
		context.stroke();
		// Description
		y+=menuFontSize;
		if (isdef(o.ship)) {
			let statText = "HP: " + o.ship.maxHealth + " REGEN: " + o.ship.regen + " SPD: " + o.ship.max_vel + " ACC " + o.ship.acceleration + " AGI " + o.ship.turn_rate;
			context.fillText(statText,x+10,y); // Wrapping must be done manually.
			y+=menuFontSize;
			let text = (menuPosition==0)?"Your current ship.":o.ship.desc;
			text = menuConfirm?"This will cost you " + o.cost + " reputation. Continue?":text;
			drawTextBlock(context,x,y,w-10,(2*h/3-menuFontSize*2),text,menuFontSize);
		}
	}

	function displaySelectSlot(context,x,w,y,h,c) {
		// Ship name, image(with higlighted weapon slots), description
		context.strokeStyle = context.fillStyle = c;
		var o = menuOptions[menuPosition];
		// Header
		y+=menuFontSize;
		context.fillText('Select Weapon Slot',x+10,y);
		y+=5;
		context.beginPath();
		context.moveTo(x, y);
		context.lineTo(x+w,y);
		context.stroke();
		// Image
		var adj = [x+w/2,y+h/6];
		context.moveTo(...player.shape[0]);
		context.beginPath();
		player.shape.forEach(p =>{
			context.lineTo(...pt_add(p, adj));
		});
		context.stroke();
		// Display weapon slots
		player.weaponSlots.forEach(s =>{
			var loc = pt_add(s.location, adj);
			context.strokeStyle = (s.weapon==false)?'#FF000055':'#FF0000AA';
			context.beginPath();
			context.arc(loc[0],loc[1], (s.secondary)?5:2, 0, 2*Math.PI);
			context.stroke();
			context.beginPath();
			context.arc(loc[0], loc[1], 10, s.angle - s.arc, s.angle + s.arc);
			context.stroke();
			if (s == o.slot) {
				context.beginPath();
				context.arc(loc[0],loc[1], 15, 0, 2*Math.PI);
				context.stroke();
			}
		});
		context.strokeStyle = c;
		y += h/3;
		context.beginPath();
		context.moveTo(x, y);
		context.lineTo(x+w,y);
		context.stroke();
		// Description
		y+=menuFontSize;
		if (isdef(o.slot)) {
			let text = "ARC: " + Math.round(o.slot.arc*180/Math.PI) + " degrees ANGLE: " + Math.round(o.slot.angle*180/Math.PI) + " degrees TYPE: " + (o.slot.secondary?'secondary':'primary');
			drawTextBlock(context,x,y,w-10,(2*h/3-menuFontSize*2),text,menuFontSize);
		}
	}

	function displayBuyWeapon(context,x,w,y,h,c) {
		// Ship name, image(with higlighted weapon slots), description
		context.strokeStyle = context.fillStyle = c;
		let o = menuOptions[menuPosition];
		// Header
		y+=menuFontSize;
		context.fillText((o.cost)?o.text+' ['+o.cost+']':o.text,x+10,y);
		y+=5;
		context.beginPath();
		context.moveTo(x, y);
		context.lineTo(x+w,y);
		context.stroke();
		// Something could go here in the future.
		//
		y += h/3;
		context.moveTo(x, y);
		context.lineTo(x+w,y);
		context.stroke();
		// Description
		y+=menuFontSize;
		if (isdef(o.wpn)) {
			let text = menuConfirm?("Install "+o.wpn.name+((o.cost)?(" for "+o.cost+" reputation"):"")+"?"):o.wpn.desc;
			drawTextBlock(context,x,y,w-10,(2*h/3-menuFontSize*2),text,menuFontSize);
		}
	}

	function handleLanded(context) {
		// Display the menu background
		context.fillStyle = menuBackgroundColor;
		var color = (playerLanded.faction==false)?planetColor:playerLanded.faction.color;
		context.strokeStyle = color;
		var mx = screenWidth/2-menuWidth/2;
		var my = screenHeight/2-menuHeight/2;
		var sx = screenWidth/2+menuWidth/2-sidebarWidth;
		context.fillRect(mx,my,menuWidth,menuHeight);
		context.beginPath();
		context.rect(mx,my,menuWidth,menuHeight);
		context.moveTo(sx,my);
		context.lineTo(sx,my+menuHeight);
		context.stroke();
		// Display the menu options
		var sy = my+menuFontSize;
		context.font = menuFont;
		
		// Display the player's reputation, first.
		context.fillStyle = color;
		var rt = playerLanded.faction==false?'Uninhabited':'Reputation: '+Math.floor(player.faction.getRelationship(playerLanded.faction));
		context.fillText(rt, sx + (i==menuPosition?20:10), sy);
		sy += 5;
		context.moveTo(sx,sy);
		context.lineTo(sx+sidebarWidth,sy);
		context.stroke();
		sy += menuFontSize;
		//
		for (var i=0; i<menuOptions.length; i++) {
			context.fillStyle = color + (menuOptions[i].function==null?'55':'');
			context.fillText((i==menuPosition?"< ":"")+menuOptions[i].text, sx + (i==menuPosition?20:10), sy);
			sy += menuFontSize*1.1;
		}
		// 
		switch (currentMenu) {
			case MAIN_MENU: displayMainMenu(context, mx, menuWidth-sidebarWidth, my, menuHeight,color);
			break;
			case BUY_SHIP: displayBuyShip(context, mx, menuWidth-sidebarWidth, my, menuHeight,color);
			break;
			case SELECT_SLOT: displaySelectSlot(context, mx, menuWidth-sidebarWidth, my, menuHeight,color);
			break;
			case BUY_WEAPON: displayBuyWeapon(context, mx, menuWidth-sidebarWidth, my, menuHeight,color);
			break;
		}
	}

	function getEVar(n) {
		// Get the selection within a given range
		return (eventVar>=0)?(eventVar%n):((eventVar%n)+n)%n;
	}

	function startEvent(en) {
		eventVar = 0;
		event = objs.events[en];
	}

	function concludeEvent() {
		if (event.special==true) {
			switch (event.name) {
				case "startEvent": 
					let factions = [objs.factions['Grey Republic'], objs.factions['Golden Empire']];
					let eVar = getEVar(factions.length);
					setPlayerShip(factions[eVar].shipTable[startingShipTier]);
					factions[eVar].armShip(player, 1); // Basic weapons
					startEvent(factions[eVar].name + "StartEvent");
				break;
			}
		} else {
			if (isdef(event.next)) {
				startEvent(event.next);
			} else {
				event = false;
			}
		}
	}

	function displayStartingShipSelection(x, y, w, h, f, highlight, context) {
		let s = f.shipTable[startingShipTier];
		context.strokeStyle=f.color;
		context.beginPath();
		context.rect(x,y,w,h);
		context.stroke();
		if (highlight) {
			context.beginPath();
			context.rect(x+5,y+5,w-10,h-10);
			context.stroke();
		}
		// Draw the ship
		let c = [x+w/2,y+h/2];
		context.beginPath();
		s.shape.forEach(p=>{
			context.lineTo(...pt_add(p,c));
		});
		context.stroke();
	}

	function handleEvent(context) {
		// Display the menu background
		context.fillStyle = menuBackgroundColor;
		context.font = menuFont;
		var color = player.faction.color;
		context.strokeStyle = color;
		var mx = screenWidth/2-menuWidth/2;
		var my = screenHeight/2-menuHeight/2;
		context.fillRect(mx,my,menuWidth,menuHeight);
		context.beginPath();
		context.rect(mx,my,menuWidth,menuHeight);
		context.stroke();
		// 
		if (event.special==true) {
			switch (event.name) {
				case "startEvent": 
					let factions = [objs.factions['Grey Republic'], objs.factions['Golden Empire']];
					let sx = mx;
					let h = menuHeight - menuFontSize*2;
					let ix = menuWidth/factions.length;
					let i = 0;
					let eVar = getEVar(factions.length);
					// Add some text at the bottom.
					let y = my+h;
					context.strokeStyle = context.fillStyle = player.faction.color;
					context.beginPath();
					context.moveTo(mx, y);
					context.lineTo(mx+menuWidth,y);
					context.stroke();
					y += menuFontSize*1.25;
					let t = "Choose.";
					context.fillText(t,mx+(menuWidth-context.measureText(t).width)/2,y);
					// Illustrate the choices.
					factions.forEach(f=>{
						let sel = eVar==i;
						displayStartingShipSelection(sx, my, ix, h, f, sel, context);
						// Display arrows if this ship is selected
						if (sel==true) {
							context.fillStyle = f.color;
							let tw = context.measureText('W/^').width;
							context.fillText('W ^',sx+(ix-tw)/2,my+menuFontSize*2);
							context.fillText('< A',(sx+tw*2),my+h-menuFontSize*2);
							context.fillText('D >',(sx+ix-tw*2),my+h-menuFontSize*2);
						}
						//
						sx += ix;
						i += 1;
					});
					
				break;
			}
		} else { // Display the relevant text
			context.strokeStyle = context.fillStyle = player.faction.color;
			let t = '^';
			let tw = context.measureText(t).width;
			context.fillText(t,mx+(menuWidth-tw)/2,my+menuFontSize);
			context.beginPath();
			context.moveTo(mx, my+menuFontSize*1.5);
			context.lineTo(mx+menuWidth, my+menuFontSize*1.5);
			context.stroke();
			drawTextBlock(context,mx+10,my+10+menuFontSize*2.5,menuWidth-20,menuHeight-20,event.text,menuFontSize)
		} 
	}

	function loop_update() {
		player.system.update(objs);
		objs.ships.forEach(function(o) {
			o.update(objs);
		});
		objs.projs.forEach(function(o) {
			o.update(objs);
		});
		objs.fx.forEach(function(o) {
			o.update(objs);
		});
	}

	function loop() {
		// Render the screen
		context.fillStyle = '#111111';
		// Neon FX
		//*
		context.lineWidth = Math.random()>.9?4:2;
		context.fillStyle += '77';
		//*/
		context.fillRect(0,0,screenWidth,screenHeight);
		// Render and update
		camera = pt_add(player.location, [-screenWidth/2, -screenHeight/2]);
		// Render a background grid
		drawGrid(context, camera);
		//
		player.system.render(context, camera, objs);
		objs.ships.forEach(function(o) {
			o.render(context, camera);
		});
		objs.projs.forEach(function(o) {
			o.render(context, camera);
		});
		objs.fx.forEach(function(o) {
			o.render(context, camera);
		});
		// Render the system map
		renderMap(objs, player, player.system, context);
		// Render the minimap
		renderMinimap(objs, player, player.system, context);
		// Render the message console
		renderMessages(context);
		// Render the player's health and weapon status
		renderPlayerHUD(context, player);
		// If the player recently jumped, display a bright flash of light
		if (player.jumpDelay > 0) {
			context.fillStyle = '#FFFFFF'+toHex(Math.round(255*player.jumpDelay/MAXJUMPDELAY));
			context.fillRect(0,0,screenWidth,screenHeight);
		}
		// Update the game state
		if (playerLanded == false && event == false) {
			loop_update();
			// If the player is jumping, jump.
			if (player.jumpTarget != false && keysDown.indexOf(E_KEY) != -1) {
				if (player.jumpReady == true && player.jumpDelay==0) {
					// Advance the universe one timestep.
					updateUniverse(objs);
					//
					player.jumpTarget.enterSystem(objs, player);
					player.jumpDelay = MAXJUMPDELAY;
				}
			}
			// If the player is landing, land.
			if (keysDown.indexOf(E_KEY) != -1 && player.altitude == 0 && player.landingTarget != false) {
				// set 'landed' status
				playerLanded = player.landingTarget;
				if (playerLanded.faction && playerLanded.faction.getRelationship(player.faction)>0) {player.health=player.maxHealth;}
				addMsg('Landed on ' + player.landingTarget.name + '.');
				planetMainMenu();
			}
		} else if (event != false) { // Menu 
			handleEvent(context);
		} else {
			// 
			handleLanded(context);
		}
		// Finally, render scan lines
		drawCRT(context);
		// Update the game state
		getAnimationFrame(loop);
	}

	window.onresize = function() {
		if(!canvas) return;

		screenWidth = canvas.clientWidth;
		screenHeight = canvas.clientHeight;

		canvas.width = screenWidth;
		canvas.height = screenHeight;
	};

	function initControls() {
		window.onkeydown = function(e) {
			if (keysDown.indexOf(e.keyCode) == -1) keysDown.push(e.keyCode);
	    	e.preventDefault();
		};

		window.onkeyup = function(e) {
			var ix = keysDown.indexOf(e.keyCode);
			if ( ix != -1) {
				keysDown.splice(ix, 1);
				keyPress(e.keyCode);
			}
	    	e.preventDefault();
		};

		window.onmousedown = function(e) {
			if (e.button == 0) {
				leftMouseDown = true;
			} else if (e.button == 2) {
				rightMouseDown = true;
			}
			e.preventDefault();
		}
		window.onmouseup = function(e) {
			if (e.button == 0) {
				leftMouseDown = false;
			} else if (e.button == 2) {
				rightMouseDown = false;
			}
			e.preventDefault();
		}
		window.oncontextmenu = function(e) {
			e.preventDefault();
		}

		window.onmousemove = function(e) {
			mousePos = [e.clientX - screenWidth/2, e.clientY - screenHeight/2];
			e.preventDefault();
		}
	}
</script>
